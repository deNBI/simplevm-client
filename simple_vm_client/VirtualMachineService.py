#
# Autogenerated by Thrift Compiler (0.22.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

import logging
import sys

from thrift.Thrift import TApplicationException, TMessageType, TProcessor, TType
from thrift.transport import TTransport
from thrift.TRecursive import fix_spec

from .ttypes import *

all_structs = []


class Iface(object):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """

    def is_version(self, version):
        """
        Parameters:
         - version

        """

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """

    def get_calculation_values(self):
        pass

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """

    def add_udp_security_group(self, server_id):
        """
        Adds udp security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """

    def add_research_environment_security_group(self, server_id, security_group_name):
        """
        Adds template security group to a server

        Parameters:
         - server_id: OpenStack id of the server
         - security_group_name

        """

    def add_metadata_to_server(self, openstack_id, metadata):
        """
        Add metadata to a server.

        Parameters:
         - openstack_id
         - metadata

        """

    def get_flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """

    def get_images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """

    def get_public_images(self):
        """
        Get Images.
        Returns: List of public Image instances.

        """

    def get_private_images(self):
        """
        Get Images.
        Returns: List of private Image instances.

        """

    def get_image(self, openstack_id, ignore_not_active):
        """
        Get an image with tag.
        Returns: image.

        Parameters:
         - openstack_id
         - ignore_not_active

        """

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """

    def resize_volume(self, volume_id, size):
        """
        Parameters:
         - volume_id
         - size

        """

    def open_port_range_for_vm_in_project(
        self, range_start, range_stop, openstack_id, ethertype, protocol
    ):
        """
        Creates/Updates a security group for a vm with a specific port range for a project

        Parameters:
         - range_start
         - range_stop
         - openstack_id
         - ethertype
         - protocol

        """

    def delete_security_group_rule(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """

    def start_server(
        self,
        flavor_name,
        image_name,
        public_key,
        servername,
        metadata,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_keys,
        research_environment,
        additional_security_group_ids,
        slurm_version,
        metadata_token,
        metadata_endpoint,
    ):
        """
        Parameters:
         - flavor_name: Name of the  Flavor to use.
         - image_name: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_keys
         - research_environment
         - additional_security_group_ids
         - slurm_version
         - metadata_token
         - metadata_endpoint

        """

    def is_bibigrid_available(self):
        pass

    def detach_ip_from_server(self, server_id, floating_ip):
        """
        Parameters:
         - server_id
         - floating_ip

        """

    def start_server_with_custom_key(
        self,
        flavor_name,
        image_name,
        servername,
        metadata,
        research_environment,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_security_group_ids,
        metadata_token,
        metadata_endpoint,
    ):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor_name: Name of the  Flavor to use.
         - image_name: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_security_group_ids
         - metadata_token
         - metadata_endpoint

        """

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """

    def create_and_deploy_playbook(
        self,
        public_key,
        openstack_id,
        conda_packages,
        research_environment_template,
        apt_packages,
        create_only_backend,
        base_url,
    ):
        """
        Create and deploy an  ansible playbook

        Parameters:
         - public_key
         - openstack_id
         - conda_packages
         - research_environment_template
         - apt_packages
         - create_only_backend
         - base_url

        """

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """

    def get_forc_url(self):
        pass

    def create_backend(self, owner, user_path, template, upstream_url):
        """
        Create a backend

        Parameters:
         - owner
         - user_path
         - template
         - upstream_url

        """

    def get_backends(self):
        """
        Get all backends

        """

    def get_backends_by_owner(self, owner):
        """
        Get all backends by owner

        Parameters:
         - owner

        """

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """

    def set_metadata_server_data(self, ip, metadata):
        """
        Parameters:
         - ip
         - metadata

        """

    def remove_metadata_server_data(self, ip):
        """
        Parameters:
         - ip

        """

    def is_metadata_server_available(self):
        pass

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """

    def add_user_to_backend(self, backend_id, user_id):
        """
        Add a user to a backend

        Parameters:
         - backend_id
         - user_id

        """

    def get_users_from_backend(self, backend_id):
        """
        Get users from a backend

        Parameters:
         - backend_id

        """

    def delete_user_from_backend(self, backend_id, user_id):
        """
        Delete user from a backend

        Parameters:
         - backend_id
         - user_id

        """

    def get_allowed_templates(self):
        pass

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """

    def scale_up_cluster(
        self, cluster_id, image_name, flavor_name, count, names, start_idx, batch_idx
    ):
        """
        Parameters:
         - cluster_id
         - image_name
         - flavor_name
         - count
         - names
         - start_idx
         - batch_idx

        """

    def add_cluster_machine(
        self,
        cluster_id,
        cluster_user,
        cluster_group_id,
        image_name,
        flavor_name,
        name,
        key_name,
        batch_idx,
        worker_idx,
    ):
        """
        Parameters:
         - cluster_id
         - cluster_user
         - cluster_group_id
         - image_name
         - flavor_name
         - name
         - key_name
         - batch_idx
         - worker_idx

        """

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """

    def get_cluster_status(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """

    def get_keypair_public_key_by_name(self, key_name):
        """
        Parameters:
         - key_name

        """

    def delete_keypair(self, key_name):
        """
        Parameters:
         - key_name

        """

    def add_default_security_groups_to_server(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """

    def get_server_by_unique_name(self, unique_name):
        """
        Parameters:
         - unique_name: Id of the server.

        """

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """

    def create_snapshot(self, openstack_id, name, username, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - username: unique username of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """

    def start_cluster(self, public_keys, master_instance, worker_instances, user):
        """
        Parameters:
         - public_keys
         - master_instance
         - worker_instances
         - user

        """

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """

    def detach_volume(self, volume_id, server_id):
        """
        Delete volume attachment

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """

    def delete_volume(self, volume_id):
        """
        Delete volume.

        Parameters:
         - volume_id

        """

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """

    def resume_server(self, openstack_id):
        """
        Resume Server.

        Parameters:
         - openstack_id: Id of the server

        """

    def create_volume(self, volume_name, volume_storage, metadata):
        """
        Create volume.

        Parameters:
         - volume_name: Name of volume
         - volume_storage: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """

    def create_volume_by_source_volume(self, volume_name, metadata, source_volume_id):
        """
        Create volume by source volume.

        Parameters:
         - volume_name: Name of volume
         - metadata: Metadata for the new volume
         - source_volume_id: ID of source volume

        """

    def create_volume_by_volume_snap(self, volume_name, metadata, volume_snap_id):
        """
        Create volume by volume snapshot.

        Parameters:
         - volume_name: Name of volume
         - metadata: Metadata for the new volume
         - volume_snap_id: ID of volume snapshot

        """

    def create_volume_snapshot(self, volume_id, name, description):
        """
        Create volume snapshot.
        Returns: ID of created snapshot

        Parameters:
         - volume_id: ID of source volume
         - name: Name for the volume snapshot
         - description: Description for the volume snapshot

        """

    def get_volume_snapshot(self, name_or_id):
        """
        Get volume snapshot.
        Returns: Snapshot object of volume snapshot

        Parameters:
         - name_or_id: Name or ID of volume snapshot

        """

    def delete_volume_snapshot(self, snapshot_id):
        """
        Delete volume snapshot.

        Parameters:
         - snapshot_id

        """

    def reboot_hard_server(self, openstack_id):
        """
        Reboot server.

        Parameters:
         - openstack_id: Id of the server

        """

    def reboot_soft_server(self, openstack_id):
        """
        Reboot server.

        Parameters:
         - openstack_id: Id of the server

        """


class Client(Iface):
    """
    This VirtualMachiine service deploys methods for creating,deleting,stopping etc. VirtualMachines in Openstack.

    """

    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def is_version(self, version):
        """
        Parameters:
         - version

        """
        self.send_is_version(version)
        return self.recv_is_version()

    def send_is_version(self, version):
        self._oprot.writeMessageBegin("is_version", TMessageType.CALL, self._seqid)
        args = is_version_args()
        args.version = version
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "is_version failed: unknown result"
        )

    def get_client_version(self):
        """
        Get Client version.
        Returns Version of the client

        """
        self.send_get_client_version()
        return self.recv_get_client_version()

    def send_get_client_version(self):
        self._oprot.writeMessageBegin(
            "get_client_version", TMessageType.CALL, self._seqid
        )
        args = get_client_version_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_client_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_client_version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_client_version failed: unknown result",
        )

    def get_gateway_ip(self):
        """
        Gets the gateway ip.

        """
        self.send_get_gateway_ip()
        return self.recv_get_gateway_ip()

    def send_get_gateway_ip(self):
        self._oprot.writeMessageBegin("get_gateway_ip", TMessageType.CALL, self._seqid)
        args = get_gateway_ip_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_gateway_ip(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_gateway_ip_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_gateway_ip failed: unknown result",
        )

    def get_calculation_values(self):
        self.send_get_calculation_values()
        return self.recv_get_calculation_values()

    def send_get_calculation_values(self):
        self._oprot.writeMessageBegin(
            "get_calculation_values", TMessageType.CALL, self._seqid
        )
        args = get_calculation_values_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_calculation_values(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_calculation_values_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_calculation_values failed: unknown result",
        )

    def import_keypair(self, keyname, public_key):
        """
        Import Key to openstack.
        Returns : keypair

        Parameters:
         - keyname: Name for the keypair
         - public_key: The public key

        """
        self.send_import_keypair(keyname, public_key)
        return self.recv_import_keypair()

    def send_import_keypair(self, keyname, public_key):
        self._oprot.writeMessageBegin("import_keypair", TMessageType.CALL, self._seqid)
        args = import_keypair_args()
        args.keyname = keyname
        args.public_key = public_key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_import_keypair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = import_keypair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "import_keypair failed: unknown result",
        )

    def get_vm_ports(self, openstack_id):
        """
        Get Ip and Port of server
        Returns:  {'IP': ip, 'PORT': port,'UDP':udp}

        Parameters:
         - openstack_id: Id of server

        """
        self.send_get_vm_ports(openstack_id)
        return self.recv_get_vm_ports()

    def send_get_vm_ports(self, openstack_id):
        self._oprot.writeMessageBegin("get_vm_ports", TMessageType.CALL, self._seqid)
        args = get_vm_ports_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_vm_ports(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_vm_ports_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.s is not None:
            raise result.s
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_vm_ports failed: unknown result"
        )

    def add_udp_security_group(self, server_id):
        """
        Adds udp security group to a server

        Parameters:
         - server_id: OpenStack id of the server

        """
        self.send_add_udp_security_group(server_id)
        self.recv_add_udp_security_group()

    def send_add_udp_security_group(self, server_id):
        self._oprot.writeMessageBegin(
            "add_udp_security_group", TMessageType.CALL, self._seqid
        )
        args = add_udp_security_group_args()
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_udp_security_group(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_udp_security_group_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        return

    def add_research_environment_security_group(self, server_id, security_group_name):
        """
        Adds template security group to a server

        Parameters:
         - server_id: OpenStack id of the server
         - security_group_name

        """
        self.send_add_research_environment_security_group(
            server_id, security_group_name
        )
        self.recv_add_research_environment_security_group()

    def send_add_research_environment_security_group(
        self, server_id, security_group_name
    ):
        self._oprot.writeMessageBegin(
            "add_research_environment_security_group", TMessageType.CALL, self._seqid
        )
        args = add_research_environment_security_group_args()
        args.server_id = server_id
        args.security_group_name = security_group_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_research_environment_security_group(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_research_environment_security_group_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        return

    def add_metadata_to_server(self, openstack_id, metadata):
        """
        Add metadata to a server.

        Parameters:
         - openstack_id
         - metadata

        """
        self.send_add_metadata_to_server(openstack_id, metadata)
        self.recv_add_metadata_to_server()

    def send_add_metadata_to_server(self, openstack_id, metadata):
        self._oprot.writeMessageBegin(
            "add_metadata_to_server", TMessageType.CALL, self._seqid
        )
        args = add_metadata_to_server_args()
        args.openstack_id = openstack_id
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_metadata_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_metadata_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.r is not None:
            raise result.r
        if result.s is not None:
            raise result.s
        return

    def get_flavors(self):
        """
        Get Flavors.
        Returns: List of flavor instances.

        """
        self.send_get_flavors()
        return self.recv_get_flavors()

    def send_get_flavors(self):
        self._oprot.writeMessageBegin("get_flavors", TMessageType.CALL, self._seqid)
        args = get_flavors_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_flavors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_flavors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_flavors failed: unknown result"
        )

    def get_images(self):
        """
        Get Images.
        Returns: List of Image instances.

        """
        self.send_get_images()
        return self.recv_get_images()

    def send_get_images(self):
        self._oprot.writeMessageBegin("get_images", TMessageType.CALL, self._seqid)
        args = get_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_images failed: unknown result"
        )

    def get_public_images(self):
        """
        Get Images.
        Returns: List of public Image instances.

        """
        self.send_get_public_images()
        return self.recv_get_public_images()

    def send_get_public_images(self):
        self._oprot.writeMessageBegin(
            "get_public_images", TMessageType.CALL, self._seqid
        )
        args = get_public_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_public_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_public_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_public_images failed: unknown result",
        )

    def get_private_images(self):
        """
        Get Images.
        Returns: List of private Image instances.

        """
        self.send_get_private_images()
        return self.recv_get_private_images()

    def send_get_private_images(self):
        self._oprot.writeMessageBegin(
            "get_private_images", TMessageType.CALL, self._seqid
        )
        args = get_private_images_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_private_images(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_private_images_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_private_images failed: unknown result",
        )

    def get_image(self, openstack_id, ignore_not_active):
        """
        Get an image with tag.
        Returns: image.

        Parameters:
         - openstack_id
         - ignore_not_active

        """
        self.send_get_image(openstack_id, ignore_not_active)
        return self.recv_get_image()

    def send_get_image(self, openstack_id, ignore_not_active):
        self._oprot.writeMessageBegin("get_image", TMessageType.CALL, self._seqid)
        args = get_image_args()
        args.openstack_id = openstack_id
        args.ignore_not_active = ignore_not_active
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.i is not None:
            raise result.i
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_image failed: unknown result"
        )

    def get_volume(self, volume_id):
        """
        Parameters:
         - volume_id

        """
        self.send_get_volume(volume_id)
        return self.recv_get_volume()

    def send_get_volume(self, volume_id):
        self._oprot.writeMessageBegin("get_volume", TMessageType.CALL, self._seqid)
        args = get_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.v is not None:
            raise result.v
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_volume failed: unknown result"
        )

    def get_volumes_by_ids(self, volume_ids):
        """
        Parameters:
         - volume_ids

        """
        self.send_get_volumes_by_ids(volume_ids)
        return self.recv_get_volumes_by_ids()

    def send_get_volumes_by_ids(self, volume_ids):
        self._oprot.writeMessageBegin(
            "get_volumes_by_ids", TMessageType.CALL, self._seqid
        )
        args = get_volumes_by_ids_args()
        args.volume_ids = volume_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volumes_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volumes_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_volumes_by_ids failed: unknown result",
        )

    def resize_volume(self, volume_id, size):
        """
        Parameters:
         - volume_id
         - size

        """
        self.send_resize_volume(volume_id, size)
        self.recv_resize_volume()

    def send_resize_volume(self, volume_id, size):
        self._oprot.writeMessageBegin("resize_volume", TMessageType.CALL, self._seqid)
        args = resize_volume_args()
        args.volume_id = volume_id
        args.size = size
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resize_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resize_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.v is not None:
            raise result.v
        return

    def open_port_range_for_vm_in_project(
        self, range_start, range_stop, openstack_id, ethertype, protocol
    ):
        """
        Creates/Updates a security group for a vm with a specific port range for a project

        Parameters:
         - range_start
         - range_stop
         - openstack_id
         - ethertype
         - protocol

        """
        self.send_open_port_range_for_vm_in_project(
            range_start, range_stop, openstack_id, ethertype, protocol
        )
        return self.recv_open_port_range_for_vm_in_project()

    def send_open_port_range_for_vm_in_project(
        self, range_start, range_stop, openstack_id, ethertype, protocol
    ):
        self._oprot.writeMessageBegin(
            "open_port_range_for_vm_in_project", TMessageType.CALL, self._seqid
        )
        args = open_port_range_for_vm_in_project_args()
        args.range_start = range_start
        args.range_stop = range_stop
        args.openstack_id = openstack_id
        args.ethertype = ethertype
        args.protocol = protocol
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_port_range_for_vm_in_project(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_port_range_for_vm_in_project_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.v is not None:
            raise result.v
        if result.o is not None:
            raise result.o
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "open_port_range_for_vm_in_project failed: unknown result",
        )

    def delete_security_group_rule(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """
        self.send_delete_security_group_rule(openstack_id)
        self.recv_delete_security_group_rule()

    def send_delete_security_group_rule(self, openstack_id):
        self._oprot.writeMessageBegin(
            "delete_security_group_rule", TMessageType.CALL, self._seqid
        )
        args = delete_security_group_rule_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_security_group_rule(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_security_group_rule_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.f is not None:
            raise result.f
        return

    def delete_server(self, openstack_id):
        """
        Delete server.
        Returns: True if deleted, False if not

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_delete_server(openstack_id)
        self.recv_delete_server()

    def send_delete_server(self, openstack_id):
        self._oprot.writeMessageBegin("delete_server", TMessageType.CALL, self._seqid)
        args = delete_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        return

    def start_server(
        self,
        flavor_name,
        image_name,
        public_key,
        servername,
        metadata,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_keys,
        research_environment,
        additional_security_group_ids,
        slurm_version,
        metadata_token,
        metadata_endpoint,
    ):
        """
        Parameters:
         - flavor_name: Name of the  Flavor to use.
         - image_name: Name of the image to use.
         - public_key: Public Key to use
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_keys
         - research_environment
         - additional_security_group_ids
         - slurm_version
         - metadata_token
         - metadata_endpoint

        """
        self.send_start_server(
            flavor_name,
            image_name,
            public_key,
            servername,
            metadata,
            volume_ids_path_new,
            volume_ids_path_attach,
            additional_keys,
            research_environment,
            additional_security_group_ids,
            slurm_version,
            metadata_token,
            metadata_endpoint,
        )
        return self.recv_start_server()

    def send_start_server(
        self,
        flavor_name,
        image_name,
        public_key,
        servername,
        metadata,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_keys,
        research_environment,
        additional_security_group_ids,
        slurm_version,
        metadata_token,
        metadata_endpoint,
    ):
        self._oprot.writeMessageBegin("start_server", TMessageType.CALL, self._seqid)
        args = start_server_args()
        args.flavor_name = flavor_name
        args.image_name = image_name
        args.public_key = public_key
        args.servername = servername
        args.metadata = metadata
        args.volume_ids_path_new = volume_ids_path_new
        args.volume_ids_path_attach = volume_ids_path_attach
        args.additional_keys = additional_keys
        args.research_environment = research_environment
        args.additional_security_group_ids = additional_security_group_ids
        args.slurm_version = slurm_version
        args.metadata_token = metadata_token
        args.metadata_endpoint = metadata_endpoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.o is not None:
            raise result.o
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "start_server failed: unknown result"
        )

    def is_bibigrid_available(self):
        self.send_is_bibigrid_available()
        return self.recv_is_bibigrid_available()

    def send_is_bibigrid_available(self):
        self._oprot.writeMessageBegin(
            "is_bibigrid_available", TMessageType.CALL, self._seqid
        )
        args = is_bibigrid_available_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_bibigrid_available(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_bibigrid_available_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "is_bibigrid_available failed: unknown result",
        )

    def detach_ip_from_server(self, server_id, floating_ip):
        """
        Parameters:
         - server_id
         - floating_ip

        """
        self.send_detach_ip_from_server(server_id, floating_ip)
        self.recv_detach_ip_from_server()

    def send_detach_ip_from_server(self, server_id, floating_ip):
        self._oprot.writeMessageBegin(
            "detach_ip_from_server", TMessageType.CALL, self._seqid
        )
        args = detach_ip_from_server_args()
        args.server_id = server_id
        args.floating_ip = floating_ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_detach_ip_from_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = detach_ip_from_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.s is not None:
            raise result.s
        return

    def start_server_with_custom_key(
        self,
        flavor_name,
        image_name,
        servername,
        metadata,
        research_environment,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_security_group_ids,
        metadata_token,
        metadata_endpoint,
    ):
        """
        Start a new server with custom key for ansible.

        Parameters:
         - flavor_name: Name of the  Flavor to use.
         - image_name: Name of the image to use.
         - servername: Name for the new server
         - metadata: Metadata for the new instance
         - research_environment
         - volume_ids_path_new
         - volume_ids_path_attach
         - additional_security_group_ids
         - metadata_token
         - metadata_endpoint

        """
        self.send_start_server_with_custom_key(
            flavor_name,
            image_name,
            servername,
            metadata,
            research_environment,
            volume_ids_path_new,
            volume_ids_path_attach,
            additional_security_group_ids,
            metadata_token,
            metadata_endpoint,
        )
        return self.recv_start_server_with_custom_key()

    def send_start_server_with_custom_key(
        self,
        flavor_name,
        image_name,
        servername,
        metadata,
        research_environment,
        volume_ids_path_new,
        volume_ids_path_attach,
        additional_security_group_ids,
        metadata_token,
        metadata_endpoint,
    ):
        self._oprot.writeMessageBegin(
            "start_server_with_custom_key", TMessageType.CALL, self._seqid
        )
        args = start_server_with_custom_key_args()
        args.flavor_name = flavor_name
        args.image_name = image_name
        args.servername = servername
        args.metadata = metadata
        args.research_environment = research_environment
        args.volume_ids_path_new = volume_ids_path_new
        args.volume_ids_path_attach = volume_ids_path_attach
        args.additional_security_group_ids = additional_security_group_ids
        args.metadata_token = metadata_token
        args.metadata_endpoint = metadata_endpoint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_server_with_custom_key(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_server_with_custom_key_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        if result.i is not None:
            raise result.i
        if result.f is not None:
            raise result.f
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "start_server_with_custom_key failed: unknown result",
        )

    def exist_server(self, name):
        """
        Check if there is an instance with name

        Parameters:
         - name

        """
        self.send_exist_server(name)
        return self.recv_exist_server()

    def send_exist_server(self, name):
        self._oprot.writeMessageBegin("exist_server", TMessageType.CALL, self._seqid)
        args = exist_server_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exist_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exist_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "exist_server failed: unknown result"
        )

    def create_and_deploy_playbook(
        self,
        public_key,
        openstack_id,
        conda_packages,
        research_environment_template,
        apt_packages,
        create_only_backend,
        base_url,
    ):
        """
        Create and deploy an  ansible playbook

        Parameters:
         - public_key
         - openstack_id
         - conda_packages
         - research_environment_template
         - apt_packages
         - create_only_backend
         - base_url

        """
        self.send_create_and_deploy_playbook(
            public_key,
            openstack_id,
            conda_packages,
            research_environment_template,
            apt_packages,
            create_only_backend,
            base_url,
        )
        return self.recv_create_and_deploy_playbook()

    def send_create_and_deploy_playbook(
        self,
        public_key,
        openstack_id,
        conda_packages,
        research_environment_template,
        apt_packages,
        create_only_backend,
        base_url,
    ):
        self._oprot.writeMessageBegin(
            "create_and_deploy_playbook", TMessageType.CALL, self._seqid
        )
        args = create_and_deploy_playbook_args()
        args.public_key = public_key
        args.openstack_id = openstack_id
        args.conda_packages = conda_packages
        args.research_environment_template = research_environment_template
        args.apt_packages = apt_packages
        args.create_only_backend = create_only_backend
        args.base_url = base_url
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_and_deploy_playbook(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_and_deploy_playbook_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.s is not None:
            raise result.s
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_and_deploy_playbook failed: unknown result",
        )

    def get_playbook_logs(self, openstack_id):
        """
        Get the logs from a playbook run

        Parameters:
         - openstack_id

        """
        self.send_get_playbook_logs(openstack_id)
        return self.recv_get_playbook_logs()

    def send_get_playbook_logs(self, openstack_id):
        self._oprot.writeMessageBegin(
            "get_playbook_logs", TMessageType.CALL, self._seqid
        )
        args = get_playbook_logs_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_playbook_logs(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_playbook_logs_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.p is not None:
            raise result.p
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_playbook_logs failed: unknown result",
        )

    def has_forc(self):
        """
        Get boolean if client has backend url configured

        """
        self.send_has_forc()
        return self.recv_has_forc()

    def send_has_forc(self):
        self._oprot.writeMessageBegin("has_forc", TMessageType.CALL, self._seqid)
        args = has_forc_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_has_forc(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = has_forc_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "has_forc failed: unknown result"
        )

    def get_forc_url(self):
        self.send_get_forc_url()
        return self.recv_get_forc_url()

    def send_get_forc_url(self):
        self._oprot.writeMessageBegin("get_forc_url", TMessageType.CALL, self._seqid)
        args = get_forc_url_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_forc_url(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_forc_url_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_forc_url failed: unknown result"
        )

    def create_backend(self, owner, user_path, template, upstream_url):
        """
        Create a backend

        Parameters:
         - owner
         - user_path
         - template
         - upstream_url

        """
        self.send_create_backend(owner, user_path, template, upstream_url)
        return self.recv_create_backend()

    def send_create_backend(self, owner, user_path, template, upstream_url):
        self._oprot.writeMessageBegin("create_backend", TMessageType.CALL, self._seqid)
        args = create_backend_args()
        args.owner = owner
        args.user_path = user_path
        args.template = template
        args.upstream_url = upstream_url
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_backend failed: unknown result",
        )

    def get_backends(self):
        """
        Get all backends

        """
        self.send_get_backends()
        return self.recv_get_backends()

    def send_get_backends(self):
        self._oprot.writeMessageBegin("get_backends", TMessageType.CALL, self._seqid)
        args = get_backends_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_backends failed: unknown result"
        )

    def get_backends_by_owner(self, owner):
        """
        Get all backends by owner

        Parameters:
         - owner

        """
        self.send_get_backends_by_owner(owner)
        return self.recv_get_backends_by_owner()

    def send_get_backends_by_owner(self, owner):
        self._oprot.writeMessageBegin(
            "get_backends_by_owner", TMessageType.CALL, self._seqid
        )
        args = get_backends_by_owner_args()
        args.owner = owner
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_owner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_owner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backends_by_owner failed: unknown result",
        )

    def get_backends_by_template(self, template):
        """
        Get all backends by template

        Parameters:
         - template

        """
        self.send_get_backends_by_template(template)
        return self.recv_get_backends_by_template()

    def send_get_backends_by_template(self, template):
        self._oprot.writeMessageBegin(
            "get_backends_by_template", TMessageType.CALL, self._seqid
        )
        args = get_backends_by_template_args()
        args.template = template
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backends_by_template(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backends_by_template_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backends_by_template failed: unknown result",
        )

    def get_backend_by_id(self, id):
        """
        Get a backend by id

        Parameters:
         - id

        """
        self.send_get_backend_by_id(id)
        return self.recv_get_backend_by_id()

    def send_get_backend_by_id(self, id):
        self._oprot.writeMessageBegin(
            "get_backend_by_id", TMessageType.CALL, self._seqid
        )
        args = get_backend_by_id_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_backend_by_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_backend_by_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.b is not None:
            raise result.b
        if result.d is not None:
            raise result.d
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_backend_by_id failed: unknown result",
        )

    def set_metadata_server_data(self, ip, metadata):
        """
        Parameters:
         - ip
         - metadata

        """
        self.send_set_metadata_server_data(ip, metadata)
        self.recv_set_metadata_server_data()

    def send_set_metadata_server_data(self, ip, metadata):
        self._oprot.writeMessageBegin(
            "set_metadata_server_data", TMessageType.CALL, self._seqid
        )
        args = set_metadata_server_data_args()
        args.ip = ip
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_metadata_server_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_metadata_server_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.m is not None:
            raise result.m
        if result.b is not None:
            raise result.b
        return

    def remove_metadata_server_data(self, ip):
        """
        Parameters:
         - ip

        """
        self.send_remove_metadata_server_data(ip)
        self.recv_remove_metadata_server_data()

    def send_remove_metadata_server_data(self, ip):
        self._oprot.writeMessageBegin(
            "remove_metadata_server_data", TMessageType.CALL, self._seqid
        )
        args = remove_metadata_server_data_args()
        args.ip = ip
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_remove_metadata_server_data(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = remove_metadata_server_data_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.m is not None:
            raise result.m
        if result.b is not None:
            raise result.b
        return

    def is_metadata_server_available(self):
        self.send_is_metadata_server_available()
        self.recv_is_metadata_server_available()

    def send_is_metadata_server_available(self):
        self._oprot.writeMessageBegin(
            "is_metadata_server_available", TMessageType.CALL, self._seqid
        )
        args = is_metadata_server_available_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_is_metadata_server_available(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = is_metadata_server_available_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.m is not None:
            raise result.m
        if result.b is not None:
            raise result.b
        return

    def delete_backend(self, id):
        """
        Delete a backend

        Parameters:
         - id

        """
        self.send_delete_backend(id)
        self.recv_delete_backend()

    def send_delete_backend(self, id):
        self._oprot.writeMessageBegin("delete_backend", TMessageType.CALL, self._seqid)
        args = delete_backend_args()
        args.id = id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.b is not None:
            raise result.b
        return

    def add_user_to_backend(self, backend_id, user_id):
        """
        Add a user to a backend

        Parameters:
         - backend_id
         - user_id

        """
        self.send_add_user_to_backend(backend_id, user_id)
        return self.recv_add_user_to_backend()

    def send_add_user_to_backend(self, backend_id, user_id):
        self._oprot.writeMessageBegin(
            "add_user_to_backend", TMessageType.CALL, self._seqid
        )
        args = add_user_to_backend_args()
        args.backend_id = backend_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_user_to_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_user_to_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.b is not None:
            raise result.b
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "add_user_to_backend failed: unknown result",
        )

    def get_users_from_backend(self, backend_id):
        """
        Get users from a backend

        Parameters:
         - backend_id

        """
        self.send_get_users_from_backend(backend_id)
        return self.recv_get_users_from_backend()

    def send_get_users_from_backend(self, backend_id):
        self._oprot.writeMessageBegin(
            "get_users_from_backend", TMessageType.CALL, self._seqid
        )
        args = get_users_from_backend_args()
        args.backend_id = backend_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_users_from_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_users_from_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.b is not None:
            raise result.b
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_users_from_backend failed: unknown result",
        )

    def delete_user_from_backend(self, backend_id, user_id):
        """
        Delete user from a backend

        Parameters:
         - backend_id
         - user_id

        """
        self.send_delete_user_from_backend(backend_id, user_id)
        return self.recv_delete_user_from_backend()

    def send_delete_user_from_backend(self, backend_id, user_id):
        self._oprot.writeMessageBegin(
            "delete_user_from_backend", TMessageType.CALL, self._seqid
        )
        args = delete_user_from_backend_args()
        args.backend_id = backend_id
        args.user_id = user_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_user_from_backend(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_user_from_backend_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.b is not None:
            raise result.b
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "delete_user_from_backend failed: unknown result",
        )

    def get_allowed_templates(self):
        self.send_get_allowed_templates()
        return self.recv_get_allowed_templates()

    def send_get_allowed_templates(self):
        self._oprot.writeMessageBegin(
            "get_allowed_templates", TMessageType.CALL, self._seqid
        )
        args = get_allowed_templates_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_allowed_templates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_allowed_templates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_allowed_templates failed: unknown result",
        )

    def get_servers(self):
        """
        Get all servers.
        Returns: List of server instances.

        """
        self.send_get_servers()
        return self.recv_get_servers()

    def send_get_servers(self):
        self._oprot.writeMessageBegin("get_servers", TMessageType.CALL, self._seqid)
        args = get_servers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_servers failed: unknown result"
        )

    def get_servers_by_ids(self, server_ids):
        """
        * Get list of servers by ids
           *

        Parameters:
         - server_ids

        """
        self.send_get_servers_by_ids(server_ids)
        return self.recv_get_servers_by_ids()

    def send_get_servers_by_ids(self, server_ids):
        self._oprot.writeMessageBegin(
            "get_servers_by_ids", TMessageType.CALL, self._seqid
        )
        args = get_servers_by_ids_args()
        args.server_ids = server_ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_ids(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_ids_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_servers_by_ids failed: unknown result",
        )

    def get_servers_by_bibigrid_id(self, bibigrid_id):
        """
        * Get servers by bibigrid cluster id.
           *

        Parameters:
         - bibigrid_id

        """
        self.send_get_servers_by_bibigrid_id(bibigrid_id)
        return self.recv_get_servers_by_bibigrid_id()

    def send_get_servers_by_bibigrid_id(self, bibigrid_id):
        self._oprot.writeMessageBegin(
            "get_servers_by_bibigrid_id", TMessageType.CALL, self._seqid
        )
        args = get_servers_by_bibigrid_id_args()
        args.bibigrid_id = bibigrid_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_servers_by_bibigrid_id(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_servers_by_bibigrid_id_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_servers_by_bibigrid_id failed: unknown result",
        )

    def scale_up_cluster(
        self, cluster_id, image_name, flavor_name, count, names, start_idx, batch_idx
    ):
        """
        Parameters:
         - cluster_id
         - image_name
         - flavor_name
         - count
         - names
         - start_idx
         - batch_idx

        """
        self.send_scale_up_cluster(
            cluster_id, image_name, flavor_name, count, names, start_idx, batch_idx
        )
        return self.recv_scale_up_cluster()

    def send_scale_up_cluster(
        self, cluster_id, image_name, flavor_name, count, names, start_idx, batch_idx
    ):
        self._oprot.writeMessageBegin(
            "scale_up_cluster", TMessageType.CALL, self._seqid
        )
        args = scale_up_cluster_args()
        args.cluster_id = cluster_id
        args.image_name = image_name
        args.flavor_name = flavor_name
        args.count = count
        args.names = names
        args.start_idx = start_idx
        args.batch_idx = batch_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_scale_up_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = scale_up_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "scale_up_cluster failed: unknown result",
        )

    def add_cluster_machine(
        self,
        cluster_id,
        cluster_user,
        cluster_group_id,
        image_name,
        flavor_name,
        name,
        key_name,
        batch_idx,
        worker_idx,
    ):
        """
        Parameters:
         - cluster_id
         - cluster_user
         - cluster_group_id
         - image_name
         - flavor_name
         - name
         - key_name
         - batch_idx
         - worker_idx

        """
        self.send_add_cluster_machine(
            cluster_id,
            cluster_user,
            cluster_group_id,
            image_name,
            flavor_name,
            name,
            key_name,
            batch_idx,
            worker_idx,
        )
        return self.recv_add_cluster_machine()

    def send_add_cluster_machine(
        self,
        cluster_id,
        cluster_user,
        cluster_group_id,
        image_name,
        flavor_name,
        name,
        key_name,
        batch_idx,
        worker_idx,
    ):
        self._oprot.writeMessageBegin(
            "add_cluster_machine", TMessageType.CALL, self._seqid
        )
        args = add_cluster_machine_args()
        args.cluster_id = cluster_id
        args.cluster_user = cluster_user
        args.cluster_group_id = cluster_group_id
        args.image_name = image_name
        args.flavor_name = flavor_name
        args.name = name
        args.key_name = key_name
        args.batch_idx = batch_idx
        args.worker_idx = worker_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_cluster_machine(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_cluster_machine_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "add_cluster_machine failed: unknown result",
        )

    def get_cluster_info(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_get_cluster_info(cluster_id)
        return self.recv_get_cluster_info()

    def send_get_cluster_info(self, cluster_id):
        self._oprot.writeMessageBegin(
            "get_cluster_info", TMessageType.CALL, self._seqid
        )
        args = get_cluster_info_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.c is not None:
            raise result.c
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_cluster_info failed: unknown result",
        )

    def get_cluster_status(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_get_cluster_status(cluster_id)
        return self.recv_get_cluster_status()

    def send_get_cluster_status(self, cluster_id):
        self._oprot.writeMessageBegin(
            "get_cluster_status", TMessageType.CALL, self._seqid
        )
        args = get_cluster_status_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_cluster_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_cluster_status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.c is not None:
            raise result.c
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_cluster_status failed: unknown result",
        )

    def get_keypair_public_key_by_name(self, key_name):
        """
        Parameters:
         - key_name

        """
        self.send_get_keypair_public_key_by_name(key_name)
        return self.recv_get_keypair_public_key_by_name()

    def send_get_keypair_public_key_by_name(self, key_name):
        self._oprot.writeMessageBegin(
            "get_keypair_public_key_by_name", TMessageType.CALL, self._seqid
        )
        args = get_keypair_public_key_by_name_args()
        args.key_name = key_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_keypair_public_key_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_keypair_public_key_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_keypair_public_key_by_name failed: unknown result",
        )

    def delete_keypair(self, key_name):
        """
        Parameters:
         - key_name

        """
        self.send_delete_keypair(key_name)
        self.recv_delete_keypair()

    def send_delete_keypair(self, key_name):
        self._oprot.writeMessageBegin("delete_keypair", TMessageType.CALL, self._seqid)
        args = delete_keypair_args()
        args.key_name = key_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_keypair(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_keypair_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def add_default_security_groups_to_server(self, openstack_id):
        """
        Parameters:
         - openstack_id

        """
        self.send_add_default_security_groups_to_server(openstack_id)
        self.recv_add_default_security_groups_to_server()

    def send_add_default_security_groups_to_server(self, openstack_id):
        self._oprot.writeMessageBegin(
            "add_default_security_groups_to_server", TMessageType.CALL, self._seqid
        )
        args = add_default_security_groups_to_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_default_security_groups_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_default_security_groups_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def get_server(self, openstack_id):
        """
        Get a Server.
        Returns: A server instance.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_get_server(openstack_id)
        return self.recv_get_server()

    def send_get_server(self, openstack_id):
        self._oprot.writeMessageBegin("get_server", TMessageType.CALL, self._seqid)
        args = get_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_server failed: unknown result"
        )

    def get_server_by_unique_name(self, unique_name):
        """
        Parameters:
         - unique_name: Id of the server.

        """
        self.send_get_server_by_unique_name(unique_name)
        return self.recv_get_server_by_unique_name()

    def send_get_server_by_unique_name(self, unique_name):
        self._oprot.writeMessageBegin(
            "get_server_by_unique_name", TMessageType.CALL, self._seqid
        )
        args = get_server_by_unique_name_args()
        args.unique_name = unique_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_server_by_unique_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_server_by_unique_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_server_by_unique_name failed: unknown result",
        )

    def stop_server(self, openstack_id):
        """
        Stop a Server.
        Returns: True if stopped, False if not.

        Parameters:
         - openstack_id: Id of the server.

        """
        self.send_stop_server(openstack_id)
        self.recv_stop_server()

    def send_stop_server(self, openstack_id):
        self._oprot.writeMessageBegin("stop_server", TMessageType.CALL, self._seqid)
        args = stop_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_stop_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = stop_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        return

    def create_snapshot(self, openstack_id, name, username, base_tags, description):
        """
        Create Snapshot.
        Returns: Id of new Snapshot


        Parameters:
         - openstack_id: Id of the server
         - name: Name of new Snapshot
         - username: unique username of the user who requested creation of Snapshot
         - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
         - description: Description of the new snapshot

        """
        self.send_create_snapshot(openstack_id, name, username, base_tags, description)
        return self.recv_create_snapshot()

    def send_create_snapshot(
        self, openstack_id, name, username, base_tags, description
    ):
        self._oprot.writeMessageBegin("create_snapshot", TMessageType.CALL, self._seqid)
        args = create_snapshot_args()
        args.openstack_id = openstack_id
        args.name = name
        args.username = username
        args.base_tags = base_tags
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_snapshot failed: unknown result",
        )

    def get_limits(self):
        """
        Get Limits of OpenStack Projekt from client.
        Returns: {'maxTotalVolumes': maxTotalVolumes, 'maxTotalVolumeGigabytes': maxTotalVolumeGigabytes,
                  'maxTotalInstances': maxTotalInstances, 'totalRamUsed': totalRamUsed,
                 'totalInstancesUsed': totalInstancesUsed}

        """
        self.send_get_limits()
        return self.recv_get_limits()

    def send_get_limits(self):
        self._oprot.writeMessageBegin("get_limits", TMessageType.CALL, self._seqid)
        args = get_limits_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_limits(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_limits_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "get_limits failed: unknown result"
        )

    def start_cluster(self, public_keys, master_instance, worker_instances, user):
        """
        Parameters:
         - public_keys
         - master_instance
         - worker_instances
         - user

        """
        self.send_start_cluster(public_keys, master_instance, worker_instances, user)
        return self.recv_start_cluster()

    def send_start_cluster(self, public_keys, master_instance, worker_instances, user):
        self._oprot.writeMessageBegin("start_cluster", TMessageType.CALL, self._seqid)
        args = start_cluster_args()
        args.public_keys = public_keys
        args.master_instance = master_instance
        args.worker_instances = worker_instances
        args.user = user
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_start_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = start_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "start_cluster failed: unknown result"
        )

    def terminate_cluster(self, cluster_id):
        """
        Parameters:
         - cluster_id

        """
        self.send_terminate_cluster(cluster_id)
        return self.recv_terminate_cluster()

    def send_terminate_cluster(self, cluster_id):
        self._oprot.writeMessageBegin(
            "terminate_cluster", TMessageType.CALL, self._seqid
        )
        args = terminate_cluster_args()
        args.cluster_id = cluster_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_terminate_cluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = terminate_cluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.c is not None:
            raise result.c
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "terminate_cluster failed: unknown result",
        )

    def delete_image(self, image_id):
        """
        Delete Image.
        Return: True if deleted, False if not

        Parameters:
         - image_id: Id of image

        """
        self.send_delete_image(image_id)
        self.recv_delete_image()

    def send_delete_image(self, image_id):
        self._oprot.writeMessageBegin("delete_image", TMessageType.CALL, self._seqid)
        args = delete_image_args()
        args.image_id = image_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_image(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_image_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        return

    def detach_volume(self, volume_id, server_id):
        """
        Delete volume attachment

        Parameters:
         - volume_id: Id of the attached volume
         - server_id: Id of the server where the volume is attached

        """
        self.send_detach_volume(volume_id, server_id)
        self.recv_detach_volume()

    def send_detach_volume(self, volume_id, server_id):
        self._oprot.writeMessageBegin("detach_volume", TMessageType.CALL, self._seqid)
        args = detach_volume_args()
        args.volume_id = volume_id
        args.server_id = server_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_detach_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = detach_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        if result.v is not None:
            raise result.v
        return

    def delete_volume(self, volume_id):
        """
        Delete volume.

        Parameters:
         - volume_id

        """
        self.send_delete_volume(volume_id)
        self.recv_delete_volume()

    def send_delete_volume(self, volume_id):
        self._oprot.writeMessageBegin("delete_volume", TMessageType.CALL, self._seqid)
        args = delete_volume_args()
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.c is not None:
            raise result.c
        if result.v is not None:
            raise result.v
        return

    def attach_volume_to_server(self, openstack_id, volume_id):
        """
        Attach volume to server.
        Returns:  True if attached, False if not

        Parameters:
         - openstack_id: Id of server
         - volume_id: Id of volume

        """
        self.send_attach_volume_to_server(openstack_id, volume_id)
        return self.recv_attach_volume_to_server()

    def send_attach_volume_to_server(self, openstack_id, volume_id):
        self._oprot.writeMessageBegin(
            "attach_volume_to_server", TMessageType.CALL, self._seqid
        )
        args = attach_volume_to_server_args()
        args.openstack_id = openstack_id
        args.volume_id = volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_attach_volume_to_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = attach_volume_to_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "attach_volume_to_server failed: unknown result",
        )

    def resume_server(self, openstack_id):
        """
        Resume Server.

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_resume_server(openstack_id)
        self.recv_resume_server()

    def send_resume_server(self, openstack_id):
        self._oprot.writeMessageBegin("resume_server", TMessageType.CALL, self._seqid)
        args = resume_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_resume_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = resume_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        return

    def create_volume(self, volume_name, volume_storage, metadata):
        """
        Create volume.

        Parameters:
         - volume_name: Name of volume
         - volume_storage: Diskspace in GB for new volume
         - metadata: Metadata for the new volume

        """
        self.send_create_volume(volume_name, volume_storage, metadata)
        return self.recv_create_volume()

    def send_create_volume(self, volume_name, volume_storage, metadata):
        self._oprot.writeMessageBegin("create_volume", TMessageType.CALL, self._seqid)
        args = create_volume_args()
        args.volume_name = volume_name
        args.volume_storage = volume_storage
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        if result.n is not None:
            raise result.n
        raise TApplicationException(
            TApplicationException.MISSING_RESULT, "create_volume failed: unknown result"
        )

    def create_volume_by_source_volume(self, volume_name, metadata, source_volume_id):
        """
        Create volume by source volume.

        Parameters:
         - volume_name: Name of volume
         - metadata: Metadata for the new volume
         - source_volume_id: ID of source volume

        """
        self.send_create_volume_by_source_volume(
            volume_name, metadata, source_volume_id
        )
        return self.recv_create_volume_by_source_volume()

    def send_create_volume_by_source_volume(
        self, volume_name, metadata, source_volume_id
    ):
        self._oprot.writeMessageBegin(
            "create_volume_by_source_volume", TMessageType.CALL, self._seqid
        )
        args = create_volume_by_source_volume_args()
        args.volume_name = volume_name
        args.metadata = metadata
        args.source_volume_id = source_volume_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume_by_source_volume(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_by_source_volume_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        if result.n is not None:
            raise result.n
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_volume_by_source_volume failed: unknown result",
        )

    def create_volume_by_volume_snap(self, volume_name, metadata, volume_snap_id):
        """
        Create volume by volume snapshot.

        Parameters:
         - volume_name: Name of volume
         - metadata: Metadata for the new volume
         - volume_snap_id: ID of volume snapshot

        """
        self.send_create_volume_by_volume_snap(volume_name, metadata, volume_snap_id)
        return self.recv_create_volume_by_volume_snap()

    def send_create_volume_by_volume_snap(self, volume_name, metadata, volume_snap_id):
        self._oprot.writeMessageBegin(
            "create_volume_by_volume_snap", TMessageType.CALL, self._seqid
        )
        args = create_volume_by_volume_snap_args()
        args.volume_name = volume_name
        args.metadata = metadata
        args.volume_snap_id = volume_snap_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume_by_volume_snap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_by_volume_snap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        if result.n is not None:
            raise result.n
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_volume_by_volume_snap failed: unknown result",
        )

    def create_volume_snapshot(self, volume_id, name, description):
        """
        Create volume snapshot.
        Returns: ID of created snapshot

        Parameters:
         - volume_id: ID of source volume
         - name: Name for the volume snapshot
         - description: Description for the volume snapshot

        """
        self.send_create_volume_snapshot(volume_id, name, description)
        return self.recv_create_volume_snapshot()

    def send_create_volume_snapshot(self, volume_id, name, description):
        self._oprot.writeMessageBegin(
            "create_volume_snapshot", TMessageType.CALL, self._seqid
        )
        args = create_volume_snapshot_args()
        args.volume_id = volume_id
        args.name = name
        args.description = description
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_volume_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_volume_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.e is not None:
            raise result.e
        if result.r is not None:
            raise result.r
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "create_volume_snapshot failed: unknown result",
        )

    def get_volume_snapshot(self, name_or_id):
        """
        Get volume snapshot.
        Returns: Snapshot object of volume snapshot

        Parameters:
         - name_or_id: Name or ID of volume snapshot

        """
        self.send_get_volume_snapshot(name_or_id)
        return self.recv_get_volume_snapshot()

    def send_get_volume_snapshot(self, name_or_id):
        self._oprot.writeMessageBegin(
            "get_volume_snapshot", TMessageType.CALL, self._seqid
        )
        args = get_volume_snapshot_args()
        args.name_or_id = name_or_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_volume_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_volume_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.r is not None:
            raise result.r
        raise TApplicationException(
            TApplicationException.MISSING_RESULT,
            "get_volume_snapshot failed: unknown result",
        )

    def delete_volume_snapshot(self, snapshot_id):
        """
        Delete volume snapshot.

        Parameters:
         - snapshot_id

        """
        self.send_delete_volume_snapshot(snapshot_id)
        self.recv_delete_volume_snapshot()

    def send_delete_volume_snapshot(self, snapshot_id):
        self._oprot.writeMessageBegin(
            "delete_volume_snapshot", TMessageType.CALL, self._seqid
        )
        args = delete_volume_snapshot_args()
        args.snapshot_id = snapshot_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_volume_snapshot(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_volume_snapshot_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.c is not None:
            raise result.c
        if result.e is not None:
            raise result.e
        return

    def reboot_hard_server(self, openstack_id):
        """
        Reboot server.

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_reboot_hard_server(openstack_id)
        self.recv_reboot_hard_server()

    def send_reboot_hard_server(self, openstack_id):
        self._oprot.writeMessageBegin(
            "reboot_hard_server", TMessageType.CALL, self._seqid
        )
        args = reboot_hard_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reboot_hard_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reboot_hard_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        return

    def reboot_soft_server(self, openstack_id):
        """
        Reboot server.

        Parameters:
         - openstack_id: Id of the server

        """
        self.send_reboot_soft_server(openstack_id)
        self.recv_reboot_soft_server()

    def send_reboot_soft_server(self, openstack_id):
        self._oprot.writeMessageBegin(
            "reboot_soft_server", TMessageType.CALL, self._seqid
        )
        args = reboot_soft_server_args()
        args.openstack_id = openstack_id
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_reboot_soft_server(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = reboot_soft_server_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.e is not None:
            raise result.e
        if result.c is not None:
            raise result.c
        return


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["is_version"] = Processor.process_is_version
        self._processMap["get_client_version"] = Processor.process_get_client_version
        self._processMap["get_gateway_ip"] = Processor.process_get_gateway_ip
        self._processMap["get_calculation_values"] = (
            Processor.process_get_calculation_values
        )
        self._processMap["import_keypair"] = Processor.process_import_keypair
        self._processMap["get_vm_ports"] = Processor.process_get_vm_ports
        self._processMap["add_udp_security_group"] = (
            Processor.process_add_udp_security_group
        )
        self._processMap["add_research_environment_security_group"] = (
            Processor.process_add_research_environment_security_group
        )
        self._processMap["add_metadata_to_server"] = (
            Processor.process_add_metadata_to_server
        )
        self._processMap["get_flavors"] = Processor.process_get_flavors
        self._processMap["get_images"] = Processor.process_get_images
        self._processMap["get_public_images"] = Processor.process_get_public_images
        self._processMap["get_private_images"] = Processor.process_get_private_images
        self._processMap["get_image"] = Processor.process_get_image
        self._processMap["get_volume"] = Processor.process_get_volume
        self._processMap["get_volumes_by_ids"] = Processor.process_get_volumes_by_ids
        self._processMap["resize_volume"] = Processor.process_resize_volume
        self._processMap["open_port_range_for_vm_in_project"] = (
            Processor.process_open_port_range_for_vm_in_project
        )
        self._processMap["delete_security_group_rule"] = (
            Processor.process_delete_security_group_rule
        )
        self._processMap["delete_server"] = Processor.process_delete_server
        self._processMap["start_server"] = Processor.process_start_server
        self._processMap["is_bibigrid_available"] = (
            Processor.process_is_bibigrid_available
        )
        self._processMap["detach_ip_from_server"] = (
            Processor.process_detach_ip_from_server
        )
        self._processMap["start_server_with_custom_key"] = (
            Processor.process_start_server_with_custom_key
        )
        self._processMap["exist_server"] = Processor.process_exist_server
        self._processMap["create_and_deploy_playbook"] = (
            Processor.process_create_and_deploy_playbook
        )
        self._processMap["get_playbook_logs"] = Processor.process_get_playbook_logs
        self._processMap["has_forc"] = Processor.process_has_forc
        self._processMap["get_forc_url"] = Processor.process_get_forc_url
        self._processMap["create_backend"] = Processor.process_create_backend
        self._processMap["get_backends"] = Processor.process_get_backends
        self._processMap["get_backends_by_owner"] = (
            Processor.process_get_backends_by_owner
        )
        self._processMap["get_backends_by_template"] = (
            Processor.process_get_backends_by_template
        )
        self._processMap["get_backend_by_id"] = Processor.process_get_backend_by_id
        self._processMap["set_metadata_server_data"] = (
            Processor.process_set_metadata_server_data
        )
        self._processMap["remove_metadata_server_data"] = (
            Processor.process_remove_metadata_server_data
        )
        self._processMap["is_metadata_server_available"] = (
            Processor.process_is_metadata_server_available
        )
        self._processMap["delete_backend"] = Processor.process_delete_backend
        self._processMap["add_user_to_backend"] = Processor.process_add_user_to_backend
        self._processMap["get_users_from_backend"] = (
            Processor.process_get_users_from_backend
        )
        self._processMap["delete_user_from_backend"] = (
            Processor.process_delete_user_from_backend
        )
        self._processMap["get_allowed_templates"] = (
            Processor.process_get_allowed_templates
        )
        self._processMap["get_servers"] = Processor.process_get_servers
        self._processMap["get_servers_by_ids"] = Processor.process_get_servers_by_ids
        self._processMap["get_servers_by_bibigrid_id"] = (
            Processor.process_get_servers_by_bibigrid_id
        )
        self._processMap["scale_up_cluster"] = Processor.process_scale_up_cluster
        self._processMap["add_cluster_machine"] = Processor.process_add_cluster_machine
        self._processMap["get_cluster_info"] = Processor.process_get_cluster_info
        self._processMap["get_cluster_status"] = Processor.process_get_cluster_status
        self._processMap["get_keypair_public_key_by_name"] = (
            Processor.process_get_keypair_public_key_by_name
        )
        self._processMap["delete_keypair"] = Processor.process_delete_keypair
        self._processMap["add_default_security_groups_to_server"] = (
            Processor.process_add_default_security_groups_to_server
        )
        self._processMap["get_server"] = Processor.process_get_server
        self._processMap["get_server_by_unique_name"] = (
            Processor.process_get_server_by_unique_name
        )
        self._processMap["stop_server"] = Processor.process_stop_server
        self._processMap["create_snapshot"] = Processor.process_create_snapshot
        self._processMap["get_limits"] = Processor.process_get_limits
        self._processMap["start_cluster"] = Processor.process_start_cluster
        self._processMap["terminate_cluster"] = Processor.process_terminate_cluster
        self._processMap["delete_image"] = Processor.process_delete_image
        self._processMap["detach_volume"] = Processor.process_detach_volume
        self._processMap["delete_volume"] = Processor.process_delete_volume
        self._processMap["attach_volume_to_server"] = (
            Processor.process_attach_volume_to_server
        )
        self._processMap["resume_server"] = Processor.process_resume_server
        self._processMap["create_volume"] = Processor.process_create_volume
        self._processMap["create_volume_by_source_volume"] = (
            Processor.process_create_volume_by_source_volume
        )
        self._processMap["create_volume_by_volume_snap"] = (
            Processor.process_create_volume_by_volume_snap
        )
        self._processMap["create_volume_snapshot"] = (
            Processor.process_create_volume_snapshot
        )
        self._processMap["get_volume_snapshot"] = Processor.process_get_volume_snapshot
        self._processMap["delete_volume_snapshot"] = (
            Processor.process_delete_volume_snapshot
        )
        self._processMap["reboot_hard_server"] = Processor.process_reboot_hard_server
        self._processMap["reboot_soft_server"] = Processor.process_reboot_soft_server
        self._on_message_begin = None

    def on_message_begin(self, func):
        self._on_message_begin = func

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if self._on_message_begin:
            self._on_message_begin(name, type, seqid)
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(
                TApplicationException.UNKNOWN_METHOD, "Unknown function %s" % (name)
            )
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_is_version(self, seqid, iprot, oprot):
        args = is_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_version_result()
        try:
            result.success = self._handler.is_version(args.version)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("is_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_client_version(self, seqid, iprot, oprot):
        args = get_client_version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_client_version_result()
        try:
            result.success = self._handler.get_client_version()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_client_version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_gateway_ip(self, seqid, iprot, oprot):
        args = get_gateway_ip_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_gateway_ip_result()
        try:
            result.success = self._handler.get_gateway_ip()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_gateway_ip", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_calculation_values(self, seqid, iprot, oprot):
        args = get_calculation_values_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_calculation_values_result()
        try:
            result.success = self._handler.get_calculation_values()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_calculation_values", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_import_keypair(self, seqid, iprot, oprot):
        args = import_keypair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = import_keypair_result()
        try:
            result.success = self._handler.import_keypair(args.keyname, args.public_key)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("import_keypair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_vm_ports(self, seqid, iprot, oprot):
        args = get_vm_ports_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_vm_ports_result()
        try:
            result.success = self._handler.get_vm_ports(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_vm_ports", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_udp_security_group(self, seqid, iprot, oprot):
        args = add_udp_security_group_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_udp_security_group_result()
        try:
            self._handler.add_udp_security_group(args.server_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_udp_security_group", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_research_environment_security_group(self, seqid, iprot, oprot):
        args = add_research_environment_security_group_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_research_environment_security_group_result()
        try:
            self._handler.add_research_environment_security_group(
                args.server_id, args.security_group_name
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin(
            "add_research_environment_security_group", msg_type, seqid
        )
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_metadata_to_server(self, seqid, iprot, oprot):
        args = add_metadata_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_metadata_to_server_result()
        try:
            self._handler.add_metadata_to_server(args.openstack_id, args.metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_metadata_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_flavors(self, seqid, iprot, oprot):
        args = get_flavors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_flavors_result()
        try:
            result.success = self._handler.get_flavors()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_flavors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_images(self, seqid, iprot, oprot):
        args = get_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_images_result()
        try:
            result.success = self._handler.get_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_public_images(self, seqid, iprot, oprot):
        args = get_public_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_public_images_result()
        try:
            result.success = self._handler.get_public_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_public_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_private_images(self, seqid, iprot, oprot):
        args = get_private_images_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_private_images_result()
        try:
            result.success = self._handler.get_private_images()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_private_images", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_image(self, seqid, iprot, oprot):
        args = get_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_image_result()
        try:
            result.success = self._handler.get_image(
                args.openstack_id, args.ignore_not_active
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ImageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume(self, seqid, iprot, oprot):
        args = get_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_result()
        try:
            result.success = self._handler.get_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except VolumeNotFoundException as v:
            msg_type = TMessageType.REPLY
            result.v = v
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volumes_by_ids(self, seqid, iprot, oprot):
        args = get_volumes_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volumes_by_ids_result()
        try:
            result.success = self._handler.get_volumes_by_ids(args.volume_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_volumes_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resize_volume(self, seqid, iprot, oprot):
        args = resize_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resize_volume_result()
        try:
            self._handler.resize_volume(args.volume_id, args.size)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except VolumeNotFoundException as v:
            msg_type = TMessageType.REPLY
            result.v = v
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("resize_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_port_range_for_vm_in_project(self, seqid, iprot, oprot):
        args = open_port_range_for_vm_in_project_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_port_range_for_vm_in_project_result()
        try:
            result.success = self._handler.open_port_range_for_vm_in_project(
                args.range_start,
                args.range_stop,
                args.openstack_id,
                args.ethertype,
                args.protocol,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except DefaultException as v:
            msg_type = TMessageType.REPLY
            result.v = v
        except OpenStackConflictException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("open_port_range_for_vm_in_project", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_security_group_rule(self, seqid, iprot, oprot):
        args = delete_security_group_rule_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_security_group_rule_result()
        try:
            self._handler.delete_security_group_rule(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except SecurityGroupRuleNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except DefaultException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_security_group_rule", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_server(self, seqid, iprot, oprot):
        args = delete_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_server_result()
        try:
            self._handler.delete_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server(self, seqid, iprot, oprot):
        args = start_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_result()
        try:
            result.success = self._handler.start_server(
                args.flavor_name,
                args.image_name,
                args.public_key,
                args.servername,
                args.metadata,
                args.volume_ids_path_new,
                args.volume_ids_path_attach,
                args.additional_keys,
                args.research_environment,
                args.additional_security_group_ids,
                args.slurm_version,
                args.metadata_token,
                args.metadata_endpoint,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NameAlreadyUsedException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ResourceNotAvailableException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ImageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except FlavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except DefaultException as o:
            msg_type = TMessageType.REPLY
            result.o = o
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_bibigrid_available(self, seqid, iprot, oprot):
        args = is_bibigrid_available_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_bibigrid_available_result()
        try:
            result.success = self._handler.is_bibigrid_available()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("is_bibigrid_available", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_detach_ip_from_server(self, seqid, iprot, oprot):
        args = detach_ip_from_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = detach_ip_from_server_result()
        try:
            self._handler.detach_ip_from_server(args.server_id, args.floating_ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("detach_ip_from_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_server_with_custom_key(self, seqid, iprot, oprot):
        args = start_server_with_custom_key_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_server_with_custom_key_result()
        try:
            result.success = self._handler.start_server_with_custom_key(
                args.flavor_name,
                args.image_name,
                args.servername,
                args.metadata,
                args.research_environment,
                args.volume_ids_path_new,
                args.volume_ids_path_attach,
                args.additional_security_group_ids,
                args.metadata_token,
                args.metadata_endpoint,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except NameAlreadyUsedException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except ResourceNotAvailableException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ImageNotFoundException as i:
            msg_type = TMessageType.REPLY
            result.i = i
        except FlavorNotFoundException as f:
            msg_type = TMessageType.REPLY
            result.f = f
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_server_with_custom_key", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exist_server(self, seqid, iprot, oprot):
        args = exist_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exist_server_result()
        try:
            result.success = self._handler.exist_server(args.name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("exist_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_and_deploy_playbook(self, seqid, iprot, oprot):
        args = create_and_deploy_playbook_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_and_deploy_playbook_result()
        try:
            result.success = self._handler.create_and_deploy_playbook(
                args.public_key,
                args.openstack_id,
                args.conda_packages,
                args.research_environment_template,
                args.apt_packages,
                args.create_only_backend,
                args.base_url,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as s:
            msg_type = TMessageType.REPLY
            result.s = s
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_and_deploy_playbook", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_playbook_logs(self, seqid, iprot, oprot):
        args = get_playbook_logs_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_playbook_logs_result()
        try:
            result.success = self._handler.get_playbook_logs(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except PlaybookNotFoundException as p:
            msg_type = TMessageType.REPLY
            result.p = p
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_playbook_logs", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_has_forc(self, seqid, iprot, oprot):
        args = has_forc_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = has_forc_result()
        try:
            result.success = self._handler.has_forc()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("has_forc", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_forc_url(self, seqid, iprot, oprot):
        args = get_forc_url_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_forc_url_result()
        try:
            result.success = self._handler.get_forc_url()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_forc_url", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_backend(self, seqid, iprot, oprot):
        args = create_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_backend_result()
        try:
            result.success = self._handler.create_backend(
                args.owner, args.user_path, args.template, args.upstream_url
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TemplateNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends(self, seqid, iprot, oprot):
        args = get_backends_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_result()
        try:
            result.success = self._handler.get_backends()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_owner(self, seqid, iprot, oprot):
        args = get_backends_by_owner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_owner_result()
        try:
            result.success = self._handler.get_backends_by_owner(args.owner)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends_by_owner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backends_by_template(self, seqid, iprot, oprot):
        args = get_backends_by_template_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backends_by_template_result()
        try:
            result.success = self._handler.get_backends_by_template(args.template)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backends_by_template", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_backend_by_id(self, seqid, iprot, oprot):
        args = get_backend_by_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_backend_by_id_result()
        try:
            result.success = self._handler.get_backend_by_id(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except BackendNotFoundException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except DefaultException as d:
            msg_type = TMessageType.REPLY
            result.d = d
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_backend_by_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_metadata_server_data(self, seqid, iprot, oprot):
        args = set_metadata_server_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_metadata_server_data_result()
        try:
            self._handler.set_metadata_server_data(args.ip, args.metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetadataServerNotAvailableException as m:
            msg_type = TMessageType.REPLY
            result.m = m
        except MetadataServerNotAllowedException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("set_metadata_server_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_remove_metadata_server_data(self, seqid, iprot, oprot):
        args = remove_metadata_server_data_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = remove_metadata_server_data_result()
        try:
            self._handler.remove_metadata_server_data(args.ip)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetadataServerNotAvailableException as m:
            msg_type = TMessageType.REPLY
            result.m = m
        except MetadataServerNotAllowedException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("remove_metadata_server_data", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_is_metadata_server_available(self, seqid, iprot, oprot):
        args = is_metadata_server_available_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = is_metadata_server_available_result()
        try:
            self._handler.is_metadata_server_available()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except MetadataServerNotAvailableException as m:
            msg_type = TMessageType.REPLY
            result.m = m
        except MetadataServerNotAllowedException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("is_metadata_server_available", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_backend(self, seqid, iprot, oprot):
        args = delete_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_backend_result()
        try:
            self._handler.delete_backend(args.id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except BackendNotFoundException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_user_to_backend(self, seqid, iprot, oprot):
        args = add_user_to_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_user_to_backend_result()
        try:
            result.success = self._handler.add_user_to_backend(
                args.backend_id, args.user_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except BackendNotFoundException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_user_to_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_users_from_backend(self, seqid, iprot, oprot):
        args = get_users_from_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_users_from_backend_result()
        try:
            result.success = self._handler.get_users_from_backend(args.backend_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except BackendNotFoundException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_users_from_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_user_from_backend(self, seqid, iprot, oprot):
        args = delete_user_from_backend_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_user_from_backend_result()
        try:
            result.success = self._handler.delete_user_from_backend(
                args.backend_id, args.user_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except BackendNotFoundException as b:
            msg_type = TMessageType.REPLY
            result.b = b
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_user_from_backend", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_allowed_templates(self, seqid, iprot, oprot):
        args = get_allowed_templates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_allowed_templates_result()
        try:
            result.success = self._handler.get_allowed_templates()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_allowed_templates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers(self, seqid, iprot, oprot):
        args = get_servers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_result()
        try:
            result.success = self._handler.get_servers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_ids(self, seqid, iprot, oprot):
        args = get_servers_by_ids_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_ids_result()
        try:
            result.success = self._handler.get_servers_by_ids(args.server_ids)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers_by_ids", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_servers_by_bibigrid_id(self, seqid, iprot, oprot):
        args = get_servers_by_bibigrid_id_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_servers_by_bibigrid_id_result()
        try:
            result.success = self._handler.get_servers_by_bibigrid_id(args.bibigrid_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_servers_by_bibigrid_id", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_scale_up_cluster(self, seqid, iprot, oprot):
        args = scale_up_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = scale_up_cluster_result()
        try:
            result.success = self._handler.scale_up_cluster(
                args.cluster_id,
                args.image_name,
                args.flavor_name,
                args.count,
                args.names,
                args.start_idx,
                args.batch_idx,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("scale_up_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_cluster_machine(self, seqid, iprot, oprot):
        args = add_cluster_machine_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_cluster_machine_result()
        try:
            result.success = self._handler.add_cluster_machine(
                args.cluster_id,
                args.cluster_user,
                args.cluster_group_id,
                args.image_name,
                args.flavor_name,
                args.name,
                args.key_name,
                args.batch_idx,
                args.worker_idx,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("add_cluster_machine", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_info(self, seqid, iprot, oprot):
        args = get_cluster_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_info_result()
        try:
            result.success = self._handler.get_cluster_info(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClusterNotFoundException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_cluster_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_cluster_status(self, seqid, iprot, oprot):
        args = get_cluster_status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_cluster_status_result()
        try:
            result.success = self._handler.get_cluster_status(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClusterNotFoundException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_cluster_status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_keypair_public_key_by_name(self, seqid, iprot, oprot):
        args = get_keypair_public_key_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_keypair_public_key_by_name_result()
        try:
            result.success = self._handler.get_keypair_public_key_by_name(args.key_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_keypair_public_key_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_keypair(self, seqid, iprot, oprot):
        args = delete_keypair_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_keypair_result()
        try:
            self._handler.delete_keypair(args.key_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_keypair", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_default_security_groups_to_server(self, seqid, iprot, oprot):
        args = add_default_security_groups_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_default_security_groups_to_server_result()
        try:
            self._handler.add_default_security_groups_to_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin(
            "add_default_security_groups_to_server", msg_type, seqid
        )
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server(self, seqid, iprot, oprot):
        args = get_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_result()
        try:
            result.success = self._handler.get_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_server_by_unique_name(self, seqid, iprot, oprot):
        args = get_server_by_unique_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_server_by_unique_name_result()
        try:
            result.success = self._handler.get_server_by_unique_name(args.unique_name)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_server_by_unique_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_stop_server(self, seqid, iprot, oprot):
        args = stop_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = stop_server_result()
        try:
            self._handler.stop_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("stop_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_snapshot(self, seqid, iprot, oprot):
        args = create_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_snapshot_result()
        try:
            result.success = self._handler.create_snapshot(
                args.openstack_id,
                args.name,
                args.username,
                args.base_tags,
                args.description,
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_limits(self, seqid, iprot, oprot):
        args = get_limits_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_limits_result()
        try:
            result.success = self._handler.get_limits()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_limits", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_start_cluster(self, seqid, iprot, oprot):
        args = start_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = start_cluster_result()
        try:
            result.success = self._handler.start_cluster(
                args.public_keys, args.master_instance, args.worker_instances, args.user
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("start_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_terminate_cluster(self, seqid, iprot, oprot):
        args = terminate_cluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = terminate_cluster_result()
        try:
            result.success = self._handler.terminate_cluster(args.cluster_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ClusterNotFoundException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("terminate_cluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_image(self, seqid, iprot, oprot):
        args = delete_image_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_image_result()
        try:
            self._handler.delete_image(args.image_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ImageNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_image", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_detach_volume(self, seqid, iprot, oprot):
        args = detach_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = detach_volume_result()
        try:
            self._handler.detach_volume(args.volume_id, args.server_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except VolumeNotFoundException as v:
            msg_type = TMessageType.REPLY
            result.v = v
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("detach_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume(self, seqid, iprot, oprot):
        args = delete_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_result()
        try:
            self._handler.delete_volume(args.volume_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except VolumeNotFoundException as v:
            msg_type = TMessageType.REPLY
            result.v = v
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_attach_volume_to_server(self, seqid, iprot, oprot):
        args = attach_volume_to_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = attach_volume_to_server_result()
        try:
            result.success = self._handler.attach_volume_to_server(
                args.openstack_id, args.volume_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except VolumeNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("attach_volume_to_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_resume_server(self, seqid, iprot, oprot):
        args = resume_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = resume_server_result()
        try:
            self._handler.resume_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("resume_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume(self, seqid, iprot, oprot):
        args = create_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_result()
        try:
            result.success = self._handler.create_volume(
                args.volume_name, args.volume_storage, args.metadata
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ResourceNotAvailableException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume_by_source_volume(self, seqid, iprot, oprot):
        args = create_volume_by_source_volume_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_by_source_volume_result()
        try:
            result.success = self._handler.create_volume_by_source_volume(
                args.volume_name, args.metadata, args.source_volume_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ResourceNotAvailableException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_volume_by_source_volume", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume_by_volume_snap(self, seqid, iprot, oprot):
        args = create_volume_by_volume_snap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_by_volume_snap_result()
        try:
            result.success = self._handler.create_volume_by_volume_snap(
                args.volume_name, args.metadata, args.volume_snap_id
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except ResourceNotAvailableException as n:
            msg_type = TMessageType.REPLY
            result.n = n
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_volume_by_volume_snap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_volume_snapshot(self, seqid, iprot, oprot):
        args = create_volume_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_volume_snapshot_result()
        try:
            result.success = self._handler.create_volume_snapshot(
                args.volume_id, args.name, args.description
            )
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except VolumeNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except DefaultException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("create_volume_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_volume_snapshot(self, seqid, iprot, oprot):
        args = get_volume_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_volume_snapshot_result()
        try:
            result.success = self._handler.get_volume_snapshot(args.name_or_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ResourceNotFoundException as r:
            msg_type = TMessageType.REPLY
            result.r = r
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("get_volume_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_volume_snapshot(self, seqid, iprot, oprot):
        args = delete_volume_snapshot_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_volume_snapshot_result()
        try:
            self._handler.delete_volume_snapshot(args.snapshot_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except DefaultException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("delete_volume_snapshot", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reboot_hard_server(self, seqid, iprot, oprot):
        args = reboot_hard_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reboot_hard_server_result()
        try:
            self._handler.reboot_hard_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("reboot_hard_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_reboot_soft_server(self, seqid, iprot, oprot):
        args = reboot_soft_server_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = reboot_soft_server_result()
        try:
            self._handler.reboot_soft_server(args.openstack_id)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except ServerNotFoundException as e:
            msg_type = TMessageType.REPLY
            result.e = e
        except OpenStackConflictException as c:
            msg_type = TMessageType.REPLY
            result.c = c
        except TApplicationException as ex:
            logging.exception("TApplication exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception("Unexpected exception in handler")
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(
                TApplicationException.INTERNAL_ERROR, "Internal error"
            )
        oprot.writeMessageBegin("reboot_soft_server", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()


# HELPER FUNCTIONS AND STRUCTURES


class is_version_args(object):
    """
    Attributes:
     - version

    """

    thrift_spec = None

    def __init__(
        self,
        version=None,
    ):
        self.version = version

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.version = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_version_args")
        if self.version is not None:
            oprot.writeFieldBegin("version", TType.DOUBLE, 1)
            oprot.writeDouble(self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_version_args)
is_version_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.DOUBLE,
        "version",
        None,
        None,
    ),  # 1
)


class is_version_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_version_result)
is_version_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class get_client_version_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_client_version_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_client_version_args)
get_client_version_args.thrift_spec = ()


class get_client_version_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_client_version_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_client_version_result)
get_client_version_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class get_gateway_ip_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_gateway_ip_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_gateway_ip_args)
get_gateway_ip_args.thrift_spec = ()


class get_gateway_ip_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype49, _vtype50, _size48) = iprot.readMapBegin()
                    for _i52 in range(_size48):
                        _key53 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val54 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key53] = _val54
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_gateway_ip_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter55, viter56 in self.success.items():
                oprot.writeString(
                    kiter55.encode("utf-8") if sys.version_info[0] == 2 else kiter55
                )
                oprot.writeString(
                    viter56.encode("utf-8") if sys.version_info[0] == 2 else viter56
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_gateway_ip_result)
get_gateway_ip_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class get_calculation_values_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_calculation_values_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_calculation_values_args)
get_calculation_values_args.thrift_spec = ()


class get_calculation_values_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype58, _vtype59, _size57) = iprot.readMapBegin()
                    for _i61 in range(_size57):
                        _key62 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val63 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key62] = _val63
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_calculation_values_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter64, viter65 in self.success.items():
                oprot.writeString(
                    kiter64.encode("utf-8") if sys.version_info[0] == 2 else kiter64
                )
                oprot.writeString(
                    viter65.encode("utf-8") if sys.version_info[0] == 2 else viter65
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_calculation_values_result)
get_calculation_values_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class import_keypair_args(object):
    """
    Attributes:
     - keyname: Name for the keypair
     - public_key: The public key

    """

    thrift_spec = None

    def __init__(
        self,
        keyname=None,
        public_key=None,
    ):
        self.keyname = keyname
        self.public_key = public_key

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.keyname = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("import_keypair_args")
        if self.keyname is not None:
            oprot.writeFieldBegin("keyname", TType.STRING, 1)
            oprot.writeString(
                self.keyname.encode("utf-8")
                if sys.version_info[0] == 2
                else self.keyname
            )
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 2)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(import_keypair_args)
import_keypair_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "keyname",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "public_key",
        "UTF8",
        None,
    ),  # 2
)


class import_keypair_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("import_keypair_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(import_keypair_result)
import_keypair_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class get_vm_ports_args(object):
    """
    Attributes:
     - openstack_id: Id of server

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_vm_ports_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_vm_ports_args)
get_vm_ports_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class get_vm_ports_result(object):
    """
    Attributes:
     - success
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        s=None,
    ):
        self.success = success
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype67, _vtype68, _size66) = iprot.readMapBegin()
                    for _i70 in range(_size66):
                        _key71 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val72 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key71] = _val72
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_vm_ports_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter73, viter74 in self.success.items():
                oprot.writeString(
                    kiter73.encode("utf-8") if sys.version_info[0] == 2 else kiter73
                )
                oprot.writeString(
                    viter74.encode("utf-8") if sys.version_info[0] == 2 else viter74
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 1)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_vm_ports_result)
get_vm_ports_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class add_udp_security_group_args(object):
    """
    Attributes:
     - server_id: OpenStack id of the server

    """

    thrift_spec = None

    def __init__(
        self,
        server_id=None,
    ):
        self.server_id = server_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_udp_security_group_args")
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 1)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_udp_security_group_args)
add_udp_security_group_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "server_id",
        "UTF8",
        None,
    ),  # 1
)


class add_udp_security_group_result(object):
    """
    Attributes:
     - r
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        r=None,
        s=None,
    ):
        self.r = r
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_udp_security_group_result")
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 2)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_udp_security_group_result)
add_udp_security_group_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 2
)


class add_research_environment_security_group_args(object):
    """
    Attributes:
     - server_id: OpenStack id of the server
     - security_group_name

    """

    thrift_spec = None

    def __init__(
        self,
        server_id=None,
        security_group_name=None,
    ):
        self.server_id = server_id
        self.security_group_name = security_group_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.security_group_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_research_environment_security_group_args")
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 1)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        if self.security_group_name is not None:
            oprot.writeFieldBegin("security_group_name", TType.STRING, 2)
            oprot.writeString(
                self.security_group_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.security_group_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_research_environment_security_group_args)
add_research_environment_security_group_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "server_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "security_group_name",
        "UTF8",
        None,
    ),  # 2
)


class add_research_environment_security_group_result(object):
    """
    Attributes:
     - r
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        r=None,
        s=None,
    ):
        self.r = r
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_research_environment_security_group_result")
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 2)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_research_environment_security_group_result)
add_research_environment_security_group_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 2
)


class add_metadata_to_server_args(object):
    """
    Attributes:
     - openstack_id
     - metadata

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
        metadata=None,
    ):
        self.openstack_id = openstack_id
        self.metadata = metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype76, _vtype77, _size75) = iprot.readMapBegin()
                    for _i79 in range(_size75):
                        _key80 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val81 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key80] = _val81
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_metadata_to_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter82, viter83 in self.metadata.items():
                oprot.writeString(
                    kiter82.encode("utf-8") if sys.version_info[0] == 2 else kiter82
                )
                oprot.writeString(
                    viter83.encode("utf-8") if sys.version_info[0] == 2 else viter83
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_metadata_to_server_args)
add_metadata_to_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 2
)


class add_metadata_to_server_result(object):
    """
    Attributes:
     - r
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        r=None,
        s=None,
    ):
        self.r = r
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_metadata_to_server_result")
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 2)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_metadata_to_server_result)
add_metadata_to_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 2
)


class get_flavors_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_flavors_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_flavors_args)
get_flavors_args.thrift_spec = ()


class get_flavors_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = Flavor()
                        _elem89.read(iprot)
                        self.success.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_flavors_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter90 in self.success:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_flavors_result)
get_flavors_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Flavor, None], False),
        None,
    ),  # 0
)


class get_images_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_images_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_images_args)
get_images_args.thrift_spec = ()


class get_images_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = Image()
                        _elem96.read(iprot)
                        self.success.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_images_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter97 in self.success:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_images_result)
get_images_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Image, None], False),
        None,
    ),  # 0
)


class get_public_images_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_public_images_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_public_images_args)
get_public_images_args.thrift_spec = ()


class get_public_images_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = Image()
                        _elem103.read(iprot)
                        self.success.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_public_images_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter104 in self.success:
                iter104.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_public_images_result)
get_public_images_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Image, None], False),
        None,
    ),  # 0
)


class get_private_images_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_private_images_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_private_images_args)
get_private_images_args.thrift_spec = ()


class get_private_images_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = Image()
                        _elem110.read(iprot)
                        self.success.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_private_images_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter111 in self.success:
                iter111.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_private_images_result)
get_private_images_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Image, None], False),
        None,
    ),  # 0
)


class get_image_args(object):
    """
    Attributes:
     - openstack_id
     - ignore_not_active

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
        ignore_not_active=None,
    ):
        self.openstack_id = openstack_id
        self.ignore_not_active = ignore_not_active

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ignore_not_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_image_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.ignore_not_active is not None:
            oprot.writeFieldBegin("ignore_not_active", TType.BOOL, 2)
            oprot.writeBool(self.ignore_not_active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_image_args)
get_image_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.BOOL,
        "ignore_not_active",
        None,
        None,
    ),  # 2
)


class get_image_result(object):
    """
    Attributes:
     - success
     - i

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        i=None,
    ):
        self.success = success
        self.i = i

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Image()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.i = ImageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_image_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin("i", TType.STRUCT, 1)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_image_result)
get_image_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Image, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "i",
        [ImageNotFoundException, None],
        None,
    ),  # 1
)


class get_volume_args(object):
    """
    Attributes:
     - volume_id

    """

    thrift_spec = None

    def __init__(
        self,
        volume_id=None,
    ):
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_args)
get_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 1
)


class get_volume_result(object):
    """
    Attributes:
     - success
     - v

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        v=None,
    ):
        self.success = success
        self.v = v

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.v = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin("v", TType.STRUCT, 1)
            self.v.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_result)
get_volume_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Volume, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "v",
        [VolumeNotFoundException, None],
        None,
    ),  # 1
)


class get_volumes_by_ids_args(object):
    """
    Attributes:
     - volume_ids

    """

    thrift_spec = None

    def __init__(
        self,
        volume_ids=None,
    ):
        self.volume_ids = volume_ids

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.volume_ids = []
                    (_etype115, _size112) = iprot.readListBegin()
                    for _i116 in range(_size112):
                        _elem117 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.volume_ids.append(_elem117)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volumes_by_ids_args")
        if self.volume_ids is not None:
            oprot.writeFieldBegin("volume_ids", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.volume_ids))
            for iter118 in self.volume_ids:
                oprot.writeString(
                    iter118.encode("utf-8") if sys.version_info[0] == 2 else iter118
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volumes_by_ids_args)
get_volumes_by_ids_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "volume_ids",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
)


class get_volumes_by_ids_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = Volume()
                        _elem124.read(iprot)
                        self.success.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volumes_by_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter125 in self.success:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volumes_by_ids_result)
get_volumes_by_ids_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Volume, None], False),
        None,
    ),  # 0
)


class resize_volume_args(object):
    """
    Attributes:
     - volume_id
     - size

    """

    thrift_spec = None

    def __init__(
        self,
        volume_id=None,
        size=None,
    ):
        self.volume_id = volume_id
        self.size = size

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resize_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin("size", TType.I32, 2)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resize_volume_args)
resize_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "size",
        None,
        None,
    ),  # 2
)


class resize_volume_result(object):
    """
    Attributes:
     - v

    """

    thrift_spec = None

    def __init__(
        self,
        v=None,
    ):
        self.v = v

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.v = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resize_volume_result")
        if self.v is not None:
            oprot.writeFieldBegin("v", TType.STRUCT, 1)
            self.v.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resize_volume_result)
resize_volume_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "v",
        [VolumeNotFoundException, None],
        None,
    ),  # 1
)


class open_port_range_for_vm_in_project_args(object):
    """
    Attributes:
     - range_start
     - range_stop
     - openstack_id
     - ethertype
     - protocol

    """

    thrift_spec = None

    def __init__(
        self,
        range_start=None,
        range_stop=None,
        openstack_id=None,
        ethertype="IPv4",
        protocol="TCP",
    ):
        self.range_start = range_start
        self.range_stop = range_stop
        self.openstack_id = openstack_id
        self.ethertype = ethertype
        self.protocol = protocol

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.range_start = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.range_stop = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.ethertype = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.protocol = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("open_port_range_for_vm_in_project_args")
        if self.range_start is not None:
            oprot.writeFieldBegin("range_start", TType.I32, 1)
            oprot.writeI32(self.range_start)
            oprot.writeFieldEnd()
        if self.range_stop is not None:
            oprot.writeFieldBegin("range_stop", TType.I32, 2)
            oprot.writeI32(self.range_stop)
            oprot.writeFieldEnd()
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 3)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.ethertype is not None:
            oprot.writeFieldBegin("ethertype", TType.STRING, 4)
            oprot.writeString(
                self.ethertype.encode("utf-8")
                if sys.version_info[0] == 2
                else self.ethertype
            )
            oprot.writeFieldEnd()
        if self.protocol is not None:
            oprot.writeFieldBegin("protocol", TType.STRING, 5)
            oprot.writeString(
                self.protocol.encode("utf-8")
                if sys.version_info[0] == 2
                else self.protocol
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(open_port_range_for_vm_in_project_args)
open_port_range_for_vm_in_project_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I32,
        "range_start",
        None,
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "range_stop",
        None,
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "ethertype",
        "UTF8",
        "IPv4",
    ),  # 4
    (
        5,
        TType.STRING,
        "protocol",
        "UTF8",
        "TCP",
    ),  # 5
)


class open_port_range_for_vm_in_project_result(object):
    """
    Attributes:
     - success
     - e
     - v
     - o

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        v=None,
        o=None,
    ):
        self.success = success
        self.e = e
        self.v = v
        self.o = o

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.v = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("open_port_range_for_vm_in_project_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin("v", TType.STRUCT, 2)
            self.v.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin("o", TType.STRUCT, 3)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(open_port_range_for_vm_in_project_result)
open_port_range_for_vm_in_project_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "v",
        [DefaultException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "o",
        [OpenStackConflictException, None],
        None,
    ),  # 3
)


class delete_security_group_rule_args(object):
    """
    Attributes:
     - openstack_id

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_security_group_rule_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_security_group_rule_args)
delete_security_group_rule_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class delete_security_group_rule_result(object):
    """
    Attributes:
     - e
     - f

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        f=None,
    ):
        self.e = e
        self.f = f

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = SecurityGroupRuleNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.f = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_security_group_rule_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 2)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_security_group_rule_result)
delete_security_group_rule_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [SecurityGroupRuleNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "f",
        [DefaultException, None],
        None,
    ),  # 2
)


class delete_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_server_args)
delete_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class delete_server_result(object):
    """
    Attributes:
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
    ):
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_server_result)
delete_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class start_server_args(object):
    """
    Attributes:
     - flavor_name: Name of the  Flavor to use.
     - image_name: Name of the image to use.
     - public_key: Public Key to use
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - volume_ids_path_new
     - volume_ids_path_attach
     - additional_keys
     - research_environment
     - additional_security_group_ids
     - slurm_version
     - metadata_token
     - metadata_endpoint

    """

    thrift_spec = None

    def __init__(
        self,
        flavor_name=None,
        image_name=None,
        public_key=None,
        servername=None,
        metadata=None,
        volume_ids_path_new=None,
        volume_ids_path_attach=None,
        additional_keys=None,
        research_environment=None,
        additional_security_group_ids=None,
        slurm_version=None,
        metadata_token=None,
        metadata_endpoint=None,
    ):
        self.flavor_name = flavor_name
        self.image_name = image_name
        self.public_key = public_key
        self.servername = servername
        self.metadata = metadata
        self.volume_ids_path_new = volume_ids_path_new
        self.volume_ids_path_attach = volume_ids_path_attach
        self.additional_keys = additional_keys
        self.research_environment = research_environment
        self.additional_security_group_ids = additional_security_group_ids
        self.slurm_version = slurm_version
        self.metadata_token = metadata_token
        self.metadata_endpoint = metadata_endpoint

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype127, _vtype128, _size126) = iprot.readMapBegin()
                    for _i130 in range(_size126):
                        _key131 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val132 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key131] = _val132
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.volume_ids_path_new = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = {}
                        (_ktype140, _vtype141, _size139) = iprot.readMapBegin()
                        for _i143 in range(_size139):
                            _key144 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val145 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem138[_key144] = _val145
                        iprot.readMapEnd()
                        self.volume_ids_path_new.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.volume_ids_path_attach = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = {}
                        (_ktype153, _vtype154, _size152) = iprot.readMapBegin()
                        for _i156 in range(_size152):
                            _key157 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val158 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem151[_key157] = _val158
                        iprot.readMapEnd()
                        self.volume_ids_path_attach.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.additional_keys = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.additional_keys.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.research_environment = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.additional_security_group_ids = []
                    (_etype168, _size165) = iprot.readListBegin()
                    for _i169 in range(_size165):
                        _elem170 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.additional_security_group_ids.append(_elem170)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.slurm_version = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.metadata_token = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.metadata_endpoint = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_args")
        if self.flavor_name is not None:
            oprot.writeFieldBegin("flavor_name", TType.STRING, 1)
            oprot.writeString(
                self.flavor_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.flavor_name
            )
            oprot.writeFieldEnd()
        if self.image_name is not None:
            oprot.writeFieldBegin("image_name", TType.STRING, 2)
            oprot.writeString(
                self.image_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_name
            )
            oprot.writeFieldEnd()
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 3)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 4)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter171, viter172 in self.metadata.items():
                oprot.writeString(
                    kiter171.encode("utf-8") if sys.version_info[0] == 2 else kiter171
                )
                oprot.writeString(
                    viter172.encode("utf-8") if sys.version_info[0] == 2 else viter172
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_new is not None:
            oprot.writeFieldBegin("volume_ids_path_new", TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_new))
            for iter173 in self.volume_ids_path_new:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter173))
                for kiter174, viter175 in iter173.items():
                    oprot.writeString(
                        kiter174.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter174
                    )
                    oprot.writeString(
                        viter175.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter175
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_attach is not None:
            oprot.writeFieldBegin("volume_ids_path_attach", TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_attach))
            for iter176 in self.volume_ids_path_attach:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter176))
                for kiter177, viter178 in iter176.items():
                    oprot.writeString(
                        kiter177.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter177
                    )
                    oprot.writeString(
                        viter178.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter178
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.additional_keys is not None:
            oprot.writeFieldBegin("additional_keys", TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.additional_keys))
            for iter179 in self.additional_keys:
                oprot.writeString(
                    iter179.encode("utf-8") if sys.version_info[0] == 2 else iter179
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.research_environment is not None:
            oprot.writeFieldBegin("research_environment", TType.STRING, 10)
            oprot.writeString(
                self.research_environment.encode("utf-8")
                if sys.version_info[0] == 2
                else self.research_environment
            )
            oprot.writeFieldEnd()
        if self.additional_security_group_ids is not None:
            oprot.writeFieldBegin("additional_security_group_ids", TType.LIST, 11)
            oprot.writeListBegin(TType.STRING, len(self.additional_security_group_ids))
            for iter180 in self.additional_security_group_ids:
                oprot.writeString(
                    iter180.encode("utf-8") if sys.version_info[0] == 2 else iter180
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.slurm_version is not None:
            oprot.writeFieldBegin("slurm_version", TType.STRING, 12)
            oprot.writeString(
                self.slurm_version.encode("utf-8")
                if sys.version_info[0] == 2
                else self.slurm_version
            )
            oprot.writeFieldEnd()
        if self.metadata_token is not None:
            oprot.writeFieldBegin("metadata_token", TType.STRING, 13)
            oprot.writeString(
                self.metadata_token.encode("utf-8")
                if sys.version_info[0] == 2
                else self.metadata_token
            )
            oprot.writeFieldEnd()
        if self.metadata_endpoint is not None:
            oprot.writeFieldBegin("metadata_endpoint", TType.STRING, 14)
            oprot.writeString(
                self.metadata_endpoint.encode("utf-8")
                if sys.version_info[0] == 2
                else self.metadata_endpoint
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_args)
start_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "flavor_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "image_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "public_key",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "servername",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 5
    None,  # 6
    (
        7,
        TType.LIST,
        "volume_ids_path_new",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 7
    (
        8,
        TType.LIST,
        "volume_ids_path_attach",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 8
    (
        9,
        TType.LIST,
        "additional_keys",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 9
    (
        10,
        TType.STRING,
        "research_environment",
        "UTF8",
        None,
    ),  # 10
    (
        11,
        TType.LIST,
        "additional_security_group_ids",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 11
    (
        12,
        TType.STRING,
        "slurm_version",
        "UTF8",
        None,
    ),  # 12
    (
        13,
        TType.STRING,
        "metadata_token",
        "UTF8",
        None,
    ),  # 13
    (
        14,
        TType.STRING,
        "metadata_endpoint",
        "UTF8",
        None,
    ),  # 14
)


class start_server_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - i
     - f
     - o

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        r=None,
        i=None,
        f=None,
        o=None,
    ):
        self.success = success
        self.e = e
        self.r = r
        self.i = i
        self.f = f
        self.o = o

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = NameAlreadyUsedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ResourceNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.i = ImageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.f = FlavorNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.o = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin("i", TType.STRUCT, 5)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 6)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.o is not None:
            oprot.writeFieldBegin("o", TType.STRUCT, 7)
            self.o.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_result)
start_server_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [NameAlreadyUsedException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "r",
        [ResourceNotAvailableException, None],
        None,
    ),  # 2
    None,  # 3
    None,  # 4
    (
        5,
        TType.STRUCT,
        "i",
        [ImageNotFoundException, None],
        None,
    ),  # 5
    (
        6,
        TType.STRUCT,
        "f",
        [FlavorNotFoundException, None],
        None,
    ),  # 6
    (
        7,
        TType.STRUCT,
        "o",
        [DefaultException, None],
        None,
    ),  # 7
)


class is_bibigrid_available_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_bibigrid_available_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_bibigrid_available_args)
is_bibigrid_available_args.thrift_spec = ()


class is_bibigrid_available_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_bibigrid_available_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_bibigrid_available_result)
is_bibigrid_available_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class detach_ip_from_server_args(object):
    """
    Attributes:
     - server_id
     - floating_ip

    """

    thrift_spec = None

    def __init__(
        self,
        server_id=None,
        floating_ip=None,
    ):
        self.server_id = server_id
        self.floating_ip = floating_ip

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.floating_ip = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("detach_ip_from_server_args")
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 1)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        if self.floating_ip is not None:
            oprot.writeFieldBegin("floating_ip", TType.STRING, 2)
            oprot.writeString(
                self.floating_ip.encode("utf-8")
                if sys.version_info[0] == 2
                else self.floating_ip
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(detach_ip_from_server_args)
detach_ip_from_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "server_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "floating_ip",
        "UTF8",
        None,
    ),  # 2
)


class detach_ip_from_server_result(object):
    """
    Attributes:
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        s=None,
    ):
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("detach_ip_from_server_result")
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 1)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(detach_ip_from_server_result)
detach_ip_from_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class start_server_with_custom_key_args(object):
    """
    Attributes:
     - flavor_name: Name of the  Flavor to use.
     - image_name: Name of the image to use.
     - servername: Name for the new server
     - metadata: Metadata for the new instance
     - research_environment
     - volume_ids_path_new
     - volume_ids_path_attach
     - additional_security_group_ids
     - metadata_token
     - metadata_endpoint

    """

    thrift_spec = None

    def __init__(
        self,
        flavor_name=None,
        image_name=None,
        servername=None,
        metadata=None,
        research_environment=None,
        volume_ids_path_new=None,
        volume_ids_path_attach=None,
        additional_security_group_ids=None,
        metadata_token=None,
        metadata_endpoint=None,
    ):
        self.flavor_name = flavor_name
        self.image_name = image_name
        self.servername = servername
        self.metadata = metadata
        self.research_environment = research_environment
        self.volume_ids_path_new = volume_ids_path_new
        self.volume_ids_path_attach = volume_ids_path_attach
        self.additional_security_group_ids = additional_security_group_ids
        self.metadata_token = metadata_token
        self.metadata_endpoint = metadata_endpoint

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.flavor_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.servername = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype182, _vtype183, _size181) = iprot.readMapBegin()
                    for _i185 in range(_size181):
                        _key186 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val187 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key186] = _val187
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.research_environment = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.volume_ids_path_new = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = {}
                        (_ktype195, _vtype196, _size194) = iprot.readMapBegin()
                        for _i198 in range(_size194):
                            _key199 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val200 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem193[_key199] = _val200
                        iprot.readMapEnd()
                        self.volume_ids_path_new.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.volume_ids_path_attach = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = {}
                        (_ktype208, _vtype209, _size207) = iprot.readMapBegin()
                        for _i211 in range(_size207):
                            _key212 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val213 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _elem206[_key212] = _val213
                        iprot.readMapEnd()
                        self.volume_ids_path_attach.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.additional_security_group_ids = []
                    (_etype217, _size214) = iprot.readListBegin()
                    for _i218 in range(_size214):
                        _elem219 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.additional_security_group_ids.append(_elem219)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.metadata_token = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.metadata_endpoint = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_with_custom_key_args")
        if self.flavor_name is not None:
            oprot.writeFieldBegin("flavor_name", TType.STRING, 1)
            oprot.writeString(
                self.flavor_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.flavor_name
            )
            oprot.writeFieldEnd()
        if self.image_name is not None:
            oprot.writeFieldBegin("image_name", TType.STRING, 2)
            oprot.writeString(
                self.image_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_name
            )
            oprot.writeFieldEnd()
        if self.servername is not None:
            oprot.writeFieldBegin("servername", TType.STRING, 3)
            oprot.writeString(
                self.servername.encode("utf-8")
                if sys.version_info[0] == 2
                else self.servername
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter220, viter221 in self.metadata.items():
                oprot.writeString(
                    kiter220.encode("utf-8") if sys.version_info[0] == 2 else kiter220
                )
                oprot.writeString(
                    viter221.encode("utf-8") if sys.version_info[0] == 2 else viter221
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.research_environment is not None:
            oprot.writeFieldBegin("research_environment", TType.STRING, 5)
            oprot.writeString(
                self.research_environment.encode("utf-8")
                if sys.version_info[0] == 2
                else self.research_environment
            )
            oprot.writeFieldEnd()
        if self.volume_ids_path_new is not None:
            oprot.writeFieldBegin("volume_ids_path_new", TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_new))
            for iter222 in self.volume_ids_path_new:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter222))
                for kiter223, viter224 in iter222.items():
                    oprot.writeString(
                        kiter223.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter223
                    )
                    oprot.writeString(
                        viter224.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter224
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.volume_ids_path_attach is not None:
            oprot.writeFieldBegin("volume_ids_path_attach", TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.volume_ids_path_attach))
            for iter225 in self.volume_ids_path_attach:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter225))
                for kiter226, viter227 in iter225.items():
                    oprot.writeString(
                        kiter226.encode("utf-8")
                        if sys.version_info[0] == 2
                        else kiter226
                    )
                    oprot.writeString(
                        viter227.encode("utf-8")
                        if sys.version_info[0] == 2
                        else viter227
                    )
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.additional_security_group_ids is not None:
            oprot.writeFieldBegin("additional_security_group_ids", TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.additional_security_group_ids))
            for iter228 in self.additional_security_group_ids:
                oprot.writeString(
                    iter228.encode("utf-8") if sys.version_info[0] == 2 else iter228
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.metadata_token is not None:
            oprot.writeFieldBegin("metadata_token", TType.STRING, 10)
            oprot.writeString(
                self.metadata_token.encode("utf-8")
                if sys.version_info[0] == 2
                else self.metadata_token
            )
            oprot.writeFieldEnd()
        if self.metadata_endpoint is not None:
            oprot.writeFieldBegin("metadata_endpoint", TType.STRING, 11)
            oprot.writeString(
                self.metadata_endpoint.encode("utf-8")
                if sys.version_info[0] == 2
                else self.metadata_endpoint
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_with_custom_key_args)
start_server_with_custom_key_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "flavor_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "image_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "servername",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "research_environment",
        "UTF8",
        None,
    ),  # 5
    None,  # 6
    (
        7,
        TType.LIST,
        "volume_ids_path_new",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 7
    (
        8,
        TType.LIST,
        "volume_ids_path_attach",
        (TType.MAP, (TType.STRING, "UTF8", TType.STRING, "UTF8", False), False),
        None,
    ),  # 8
    (
        9,
        TType.LIST,
        "additional_security_group_ids",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 9
    (
        10,
        TType.STRING,
        "metadata_token",
        "UTF8",
        None,
    ),  # 10
    (
        11,
        TType.STRING,
        "metadata_endpoint",
        "UTF8",
        None,
    ),  # 11
)


class start_server_with_custom_key_result(object):
    """
    Attributes:
     - success
     - e
     - r
     - i
     - f
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        r=None,
        i=None,
        f=None,
        d=None,
    ):
        self.success = success
        self.e = e
        self.r = r
        self.i = i
        self.f = f
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = NameAlreadyUsedException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = ResourceNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.i = ImageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.f = FlavorNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_server_with_custom_key_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.i is not None:
            oprot.writeFieldBegin("i", TType.STRUCT, 3)
            self.i.write(oprot)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin("f", TType.STRUCT, 4)
            self.f.write(oprot)
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 5)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_server_with_custom_key_result)
start_server_with_custom_key_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [NameAlreadyUsedException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "r",
        [ResourceNotAvailableException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "i",
        [ImageNotFoundException, None],
        None,
    ),  # 3
    (
        4,
        TType.STRUCT,
        "f",
        [FlavorNotFoundException, None],
        None,
    ),  # 4
    (
        5,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 5
)


class exist_server_args(object):
    """
    Attributes:
     - name

    """

    thrift_spec = None

    def __init__(
        self,
        name=None,
    ):
        self.name = name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("exist_server_args")
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 1)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exist_server_args)
exist_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 1
)


class exist_server_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("exist_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(exist_server_result)
exist_server_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class create_and_deploy_playbook_args(object):
    """
    Attributes:
     - public_key
     - openstack_id
     - conda_packages
     - research_environment_template
     - apt_packages
     - create_only_backend
     - base_url

    """

    thrift_spec = None

    def __init__(
        self,
        public_key=None,
        openstack_id=None,
        conda_packages=None,
        research_environment_template=None,
        apt_packages=None,
        create_only_backend=None,
        base_url=None,
    ):
        self.public_key = public_key
        self.openstack_id = openstack_id
        self.conda_packages = conda_packages
        self.research_environment_template = research_environment_template
        self.apt_packages = apt_packages
        self.create_only_backend = create_only_backend
        self.base_url = base_url

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.public_key = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.conda_packages = []
                    (_etype232, _size229) = iprot.readListBegin()
                    for _i233 in range(_size229):
                        _elem234 = CondaPackage()
                        _elem234.read(iprot)
                        self.conda_packages.append(_elem234)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.research_environment_template = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.apt_packages = []
                    (_etype238, _size235) = iprot.readListBegin()
                    for _i239 in range(_size235):
                        _elem240 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.apt_packages.append(_elem240)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.create_only_backend = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.base_url = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_and_deploy_playbook_args")
        if self.public_key is not None:
            oprot.writeFieldBegin("public_key", TType.STRING, 1)
            oprot.writeString(
                self.public_key.encode("utf-8")
                if sys.version_info[0] == 2
                else self.public_key
            )
            oprot.writeFieldEnd()
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 2)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.conda_packages is not None:
            oprot.writeFieldBegin("conda_packages", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.conda_packages))
            for iter241 in self.conda_packages:
                iter241.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.research_environment_template is not None:
            oprot.writeFieldBegin("research_environment_template", TType.STRING, 4)
            oprot.writeString(
                self.research_environment_template.encode("utf-8")
                if sys.version_info[0] == 2
                else self.research_environment_template
            )
            oprot.writeFieldEnd()
        if self.apt_packages is not None:
            oprot.writeFieldBegin("apt_packages", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.apt_packages))
            for iter242 in self.apt_packages:
                oprot.writeString(
                    iter242.encode("utf-8") if sys.version_info[0] == 2 else iter242
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.create_only_backend is not None:
            oprot.writeFieldBegin("create_only_backend", TType.BOOL, 6)
            oprot.writeBool(self.create_only_backend)
            oprot.writeFieldEnd()
        if self.base_url is not None:
            oprot.writeFieldBegin("base_url", TType.STRING, 7)
            oprot.writeString(
                self.base_url.encode("utf-8")
                if sys.version_info[0] == 2
                else self.base_url
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_and_deploy_playbook_args)
create_and_deploy_playbook_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "public_key",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "conda_packages",
        (TType.STRUCT, [CondaPackage, None], False),
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "research_environment_template",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "apt_packages",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 5
    (
        6,
        TType.BOOL,
        "create_only_backend",
        None,
        None,
    ),  # 6
    (
        7,
        TType.STRING,
        "base_url",
        "UTF8",
        None,
    ),  # 7
)


class create_and_deploy_playbook_result(object):
    """
    Attributes:
     - success
     - s

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        s=None,
    ):
        self.success = success
        self.s = s

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.s = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_and_deploy_playbook_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.s is not None:
            oprot.writeFieldBegin("s", TType.STRUCT, 1)
            self.s.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_and_deploy_playbook_result)
create_and_deploy_playbook_result.thrift_spec = (
    (
        0,
        TType.I32,
        "success",
        None,
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "s",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class get_playbook_logs_args(object):
    """
    Attributes:
     - openstack_id

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_playbook_logs_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_playbook_logs_args)
get_playbook_logs_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class get_playbook_logs_result(object):
    """
    Attributes:
     - success
     - p

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        p=None,
    ):
        self.success = success
        self.p = p

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PlaybookResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.p = PlaybookNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_playbook_logs_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.p is not None:
            oprot.writeFieldBegin("p", TType.STRUCT, 1)
            self.p.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_playbook_logs_result)
get_playbook_logs_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [PlaybookResult, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "p",
        [PlaybookNotFoundException, None],
        None,
    ),  # 1
)


class has_forc_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("has_forc_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(has_forc_args)
has_forc_args.thrift_spec = ()


class has_forc_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("has_forc_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(has_forc_result)
has_forc_result.thrift_spec = (
    (
        0,
        TType.BOOL,
        "success",
        None,
        None,
    ),  # 0
)


class get_forc_url_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_forc_url_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_forc_url_args)
get_forc_url_args.thrift_spec = ()


class get_forc_url_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_forc_url_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_forc_url_result)
get_forc_url_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class create_backend_args(object):
    """
    Attributes:
     - owner
     - user_path
     - template
     - upstream_url

    """

    thrift_spec = None

    def __init__(
        self,
        owner=None,
        user_path=None,
        template=None,
        upstream_url=None,
    ):
        self.owner = owner
        self.user_path = user_path
        self.template = template
        self.upstream_url = upstream_url

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.owner = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_path = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.template = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.upstream_url = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_backend_args")
        if self.owner is not None:
            oprot.writeFieldBegin("owner", TType.STRING, 1)
            oprot.writeString(
                self.owner.encode("utf-8") if sys.version_info[0] == 2 else self.owner
            )
            oprot.writeFieldEnd()
        if self.user_path is not None:
            oprot.writeFieldBegin("user_path", TType.STRING, 2)
            oprot.writeString(
                self.user_path.encode("utf-8")
                if sys.version_info[0] == 2
                else self.user_path
            )
            oprot.writeFieldEnd()
        if self.template is not None:
            oprot.writeFieldBegin("template", TType.STRING, 3)
            oprot.writeString(
                self.template.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template
            )
            oprot.writeFieldEnd()
        if self.upstream_url is not None:
            oprot.writeFieldBegin("upstream_url", TType.STRING, 4)
            oprot.writeString(
                self.upstream_url.encode("utf-8")
                if sys.version_info[0] == 2
                else self.upstream_url
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_backend_args)
create_backend_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "owner",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "user_path",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "template",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "upstream_url",
        "UTF8",
        None,
    ),  # 4
)


class create_backend_result(object):
    """
    Attributes:
     - success
     - e
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        d=None,
    ):
        self.success = success
        self.e = e
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = TemplateNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 2)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_backend_result)
create_backend_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Backend, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [TemplateNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 2
)


class get_backends_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_args)
get_backends_args.thrift_spec = ()


class get_backends_result(object):
    """
    Attributes:
     - success
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        d=None,
    ):
        self.success = success
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = Backend()
                        _elem248.read(iprot)
                        self.success.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter249 in self.success:
                iter249.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 1)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_result)
get_backends_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Backend, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 1
)


class get_backends_by_owner_args(object):
    """
    Attributes:
     - owner

    """

    thrift_spec = None

    def __init__(
        self,
        owner=None,
    ):
        self.owner = owner

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.owner = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_owner_args")
        if self.owner is not None:
            oprot.writeFieldBegin("owner", TType.STRING, 1)
            oprot.writeString(
                self.owner.encode("utf-8") if sys.version_info[0] == 2 else self.owner
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_owner_args)
get_backends_by_owner_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "owner",
        "UTF8",
        None,
    ),  # 1
)


class get_backends_by_owner_result(object):
    """
    Attributes:
     - success
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        d=None,
    ):
        self.success = success
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype253, _size250) = iprot.readListBegin()
                    for _i254 in range(_size250):
                        _elem255 = Backend()
                        _elem255.read(iprot)
                        self.success.append(_elem255)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_owner_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter256 in self.success:
                iter256.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 1)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_owner_result)
get_backends_by_owner_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Backend, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 1
)


class get_backends_by_template_args(object):
    """
    Attributes:
     - template

    """

    thrift_spec = None

    def __init__(
        self,
        template=None,
    ):
        self.template = template

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.template = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_template_args")
        if self.template is not None:
            oprot.writeFieldBegin("template", TType.STRING, 1)
            oprot.writeString(
                self.template.encode("utf-8")
                if sys.version_info[0] == 2
                else self.template
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_template_args)
get_backends_by_template_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "template",
        "UTF8",
        None,
    ),  # 1
)


class get_backends_by_template_result(object):
    """
    Attributes:
     - success
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        d=None,
    ):
        self.success = success
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype260, _size257) = iprot.readListBegin()
                    for _i261 in range(_size257):
                        _elem262 = Backend()
                        _elem262.read(iprot)
                        self.success.append(_elem262)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backends_by_template_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter263 in self.success:
                iter263.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 1)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backends_by_template_result)
get_backends_by_template_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [Backend, None], False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 1
)


class get_backend_by_id_args(object):
    """
    Attributes:
     - id

    """

    thrift_spec = None

    def __init__(
        self,
        id=None,
    ):
        self.id = id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backend_by_id_args")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backend_by_id_args)
get_backend_by_id_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "id",
        None,
        None,
    ),  # 1
)


class get_backend_by_id_result(object):
    """
    Attributes:
     - success
     - b
     - d

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        b=None,
        d=None,
    ):
        self.success = success
        self.b = b
        self.d = d

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Backend()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.b = BackendNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.d = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_backend_by_id_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 1)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        if self.d is not None:
            oprot.writeFieldBegin("d", TType.STRUCT, 2)
            self.d.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_backend_by_id_result)
get_backend_by_id_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Backend, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "b",
        [BackendNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "d",
        [DefaultException, None],
        None,
    ),  # 2
)


class set_metadata_server_data_args(object):
    """
    Attributes:
     - ip
     - metadata

    """

    thrift_spec = None

    def __init__(
        self,
        ip=None,
        metadata=None,
    ):
        self.ip = ip
        self.metadata = metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.metadata = VirtualMachineServerMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("set_metadata_server_data_args")
        if self.ip is not None:
            oprot.writeFieldBegin("ip", TType.STRING, 1)
            oprot.writeString(
                self.ip.encode("utf-8") if sys.version_info[0] == 2 else self.ip
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.STRUCT, 3)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_metadata_server_data_args)
set_metadata_server_data_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "ip",
        "UTF8",
        None,
    ),  # 1
    None,  # 2
    (
        3,
        TType.STRUCT,
        "metadata",
        [VirtualMachineServerMetadata, None],
        None,
    ),  # 3
)


class set_metadata_server_data_result(object):
    """
    Attributes:
     - m
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        m=None,
        b=None,
    ):
        self.m = m
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.m = MetadataServerNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.b = MetadataServerNotAllowedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("set_metadata_server_data_result")
        if self.m is not None:
            oprot.writeFieldBegin("m", TType.STRUCT, 1)
            self.m.write(oprot)
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 2)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(set_metadata_server_data_result)
set_metadata_server_data_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "m",
        [MetadataServerNotAvailableException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "b",
        [MetadataServerNotAllowedException, None],
        None,
    ),  # 2
)


class remove_metadata_server_data_args(object):
    """
    Attributes:
     - ip

    """

    thrift_spec = None

    def __init__(
        self,
        ip=None,
    ):
        self.ip = ip

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ip = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("remove_metadata_server_data_args")
        if self.ip is not None:
            oprot.writeFieldBegin("ip", TType.STRING, 1)
            oprot.writeString(
                self.ip.encode("utf-8") if sys.version_info[0] == 2 else self.ip
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_metadata_server_data_args)
remove_metadata_server_data_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "ip",
        "UTF8",
        None,
    ),  # 1
)


class remove_metadata_server_data_result(object):
    """
    Attributes:
     - m
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        m=None,
        b=None,
    ):
        self.m = m
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.m = MetadataServerNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.b = MetadataServerNotAllowedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("remove_metadata_server_data_result")
        if self.m is not None:
            oprot.writeFieldBegin("m", TType.STRUCT, 1)
            self.m.write(oprot)
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 2)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(remove_metadata_server_data_result)
remove_metadata_server_data_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "m",
        [MetadataServerNotAvailableException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "b",
        [MetadataServerNotAllowedException, None],
        None,
    ),  # 2
)


class is_metadata_server_available_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_metadata_server_available_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_metadata_server_available_args)
is_metadata_server_available_args.thrift_spec = ()


class is_metadata_server_available_result(object):
    """
    Attributes:
     - m
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        m=None,
        b=None,
    ):
        self.m = m
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.m = MetadataServerNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.b = MetadataServerNotAllowedException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("is_metadata_server_available_result")
        if self.m is not None:
            oprot.writeFieldBegin("m", TType.STRUCT, 1)
            self.m.write(oprot)
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 2)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(is_metadata_server_available_result)
is_metadata_server_available_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "m",
        [MetadataServerNotAvailableException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "b",
        [MetadataServerNotAllowedException, None],
        None,
    ),  # 2
)


class delete_backend_args(object):
    """
    Attributes:
     - id

    """

    thrift_spec = None

    def __init__(
        self,
        id=None,
    ):
        self.id = id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_backend_args")
        if self.id is not None:
            oprot.writeFieldBegin("id", TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_backend_args)
delete_backend_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "id",
        None,
        None,
    ),  # 1
)


class delete_backend_result(object):
    """
    Attributes:
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        b=None,
    ):
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.b = BackendNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_backend_result")
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 1)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_backend_result)
delete_backend_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "b",
        [BackendNotFoundException, None],
        None,
    ),  # 1
)


class add_user_to_backend_args(object):
    """
    Attributes:
     - backend_id
     - user_id

    """

    thrift_spec = None

    def __init__(
        self,
        backend_id=None,
        user_id=None,
    ):
        self.backend_id = backend_id
        self.user_id = user_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_user_to_backend_args")
        if self.backend_id is not None:
            oprot.writeFieldBegin("backend_id", TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin("user_id", TType.STRING, 2)
            oprot.writeString(
                self.user_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.user_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_user_to_backend_args)
add_user_to_backend_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "backend_id",
        None,
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "user_id",
        "UTF8",
        None,
    ),  # 2
)


class add_user_to_backend_result(object):
    """
    Attributes:
     - success
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        b=None,
    ):
        self.success = success
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype265, _vtype266, _size264) = iprot.readMapBegin()
                    for _i268 in range(_size264):
                        _key269 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val270 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key269] = _val270
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.b = BackendNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_user_to_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter271, viter272 in self.success.items():
                oprot.writeString(
                    kiter271.encode("utf-8") if sys.version_info[0] == 2 else kiter271
                )
                oprot.writeString(
                    viter272.encode("utf-8") if sys.version_info[0] == 2 else viter272
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 1)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_user_to_backend_result)
add_user_to_backend_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "b",
        [BackendNotFoundException, None],
        None,
    ),  # 1
)


class get_users_from_backend_args(object):
    """
    Attributes:
     - backend_id

    """

    thrift_spec = None

    def __init__(
        self,
        backend_id=None,
    ):
        self.backend_id = backend_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_users_from_backend_args")
        if self.backend_id is not None:
            oprot.writeFieldBegin("backend_id", TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_users_from_backend_args)
get_users_from_backend_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "backend_id",
        None,
        None,
    ),  # 1
)


class get_users_from_backend_result(object):
    """
    Attributes:
     - success
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        b=None,
    ):
        self.success = success
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype276, _size273) = iprot.readListBegin()
                    for _i277 in range(_size273):
                        _elem278 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success.append(_elem278)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.b = BackendNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_users_from_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter279 in self.success:
                oprot.writeString(
                    iter279.encode("utf-8") if sys.version_info[0] == 2 else iter279
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 1)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_users_from_backend_result)
get_users_from_backend_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "b",
        [BackendNotFoundException, None],
        None,
    ),  # 1
)


class delete_user_from_backend_args(object):
    """
    Attributes:
     - backend_id
     - user_id

    """

    thrift_spec = None

    def __init__(
        self,
        backend_id=None,
        user_id=None,
    ):
        self.backend_id = backend_id
        self.user_id = user_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.backend_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_user_from_backend_args")
        if self.backend_id is not None:
            oprot.writeFieldBegin("backend_id", TType.I64, 1)
            oprot.writeI64(self.backend_id)
            oprot.writeFieldEnd()
        if self.user_id is not None:
            oprot.writeFieldBegin("user_id", TType.STRING, 2)
            oprot.writeString(
                self.user_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.user_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_user_from_backend_args)
delete_user_from_backend_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.I64,
        "backend_id",
        None,
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "user_id",
        "UTF8",
        None,
    ),  # 2
)


class delete_user_from_backend_result(object):
    """
    Attributes:
     - success
     - b

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        b=None,
    ):
        self.success = success
        self.b = b

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype281, _vtype282, _size280) = iprot.readMapBegin()
                    for _i284 in range(_size280):
                        _key285 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val286 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key285] = _val286
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.b = BackendNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_user_from_backend_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter287, viter288 in self.success.items():
                oprot.writeString(
                    kiter287.encode("utf-8") if sys.version_info[0] == 2 else kiter287
                )
                oprot.writeString(
                    viter288.encode("utf-8") if sys.version_info[0] == 2 else viter288
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.b is not None:
            oprot.writeFieldBegin("b", TType.STRUCT, 1)
            self.b.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_user_from_backend_result)
delete_user_from_backend_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "b",
        [BackendNotFoundException, None],
        None,
    ),  # 1
)


class get_allowed_templates_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_allowed_templates_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_allowed_templates_args)
get_allowed_templates_args.thrift_spec = ()


class get_allowed_templates_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype292, _size289) = iprot.readListBegin()
                    for _i293 in range(_size289):
                        _elem294 = ResearchEnvironmentTemplate()
                        _elem294.read(iprot)
                        self.success.append(_elem294)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_allowed_templates_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter295 in self.success:
                iter295.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_allowed_templates_result)
get_allowed_templates_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [ResearchEnvironmentTemplate, None], False),
        None,
    ),  # 0
)


class get_servers_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_args)
get_servers_args.thrift_spec = ()


class get_servers_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype299, _size296) = iprot.readListBegin()
                    for _i300 in range(_size296):
                        _elem301 = VM()
                        _elem301.read(iprot)
                        self.success.append(_elem301)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter302 in self.success:
                iter302.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_result)
get_servers_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [VM, None], False),
        None,
    ),  # 0
)


class get_servers_by_ids_args(object):
    """
    Attributes:
     - server_ids

    """

    thrift_spec = None

    def __init__(
        self,
        server_ids=None,
    ):
        self.server_ids = server_ids

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.server_ids = []
                    (_etype306, _size303) = iprot.readListBegin()
                    for _i307 in range(_size303):
                        _elem308 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.server_ids.append(_elem308)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_ids_args")
        if self.server_ids is not None:
            oprot.writeFieldBegin("server_ids", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.server_ids))
            for iter309 in self.server_ids:
                oprot.writeString(
                    iter309.encode("utf-8") if sys.version_info[0] == 2 else iter309
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_ids_args)
get_servers_by_ids_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "server_ids",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
)


class get_servers_by_ids_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype313, _size310) = iprot.readListBegin()
                    for _i314 in range(_size310):
                        _elem315 = VM()
                        _elem315.read(iprot)
                        self.success.append(_elem315)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_ids_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter316 in self.success:
                iter316.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_ids_result)
get_servers_by_ids_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [VM, None], False),
        None,
    ),  # 0
)


class get_servers_by_bibigrid_id_args(object):
    """
    Attributes:
     - bibigrid_id

    """

    thrift_spec = None

    def __init__(
        self,
        bibigrid_id=None,
    ):
        self.bibigrid_id = bibigrid_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.bibigrid_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_bibigrid_id_args")
        if self.bibigrid_id is not None:
            oprot.writeFieldBegin("bibigrid_id", TType.STRING, 1)
            oprot.writeString(
                self.bibigrid_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.bibigrid_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_bibigrid_id_args)
get_servers_by_bibigrid_id_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "bibigrid_id",
        "UTF8",
        None,
    ),  # 1
)


class get_servers_by_bibigrid_id_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype320, _size317) = iprot.readListBegin()
                    for _i321 in range(_size317):
                        _elem322 = VM()
                        _elem322.read(iprot)
                        self.success.append(_elem322)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_servers_by_bibigrid_id_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter323 in self.success:
                iter323.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_servers_by_bibigrid_id_result)
get_servers_by_bibigrid_id_result.thrift_spec = (
    (
        0,
        TType.LIST,
        "success",
        (TType.STRUCT, [VM, None], False),
        None,
    ),  # 0
)


class scale_up_cluster_args(object):
    """
    Attributes:
     - cluster_id
     - image_name
     - flavor_name
     - count
     - names
     - start_idx
     - batch_idx

    """

    thrift_spec = None

    def __init__(
        self,
        cluster_id=None,
        image_name=None,
        flavor_name=None,
        count=None,
        names=None,
        start_idx=None,
        batch_idx=None,
    ):
        self.cluster_id = cluster_id
        self.image_name = image_name
        self.flavor_name = flavor_name
        self.count = count
        self.names = names
        self.start_idx = start_idx
        self.batch_idx = batch_idx

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.image_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.flavor_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.names.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.start_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.batch_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("scale_up_cluster_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        if self.image_name is not None:
            oprot.writeFieldBegin("image_name", TType.STRING, 2)
            oprot.writeString(
                self.image_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_name
            )
            oprot.writeFieldEnd()
        if self.flavor_name is not None:
            oprot.writeFieldBegin("flavor_name", TType.STRING, 3)
            oprot.writeString(
                self.flavor_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.flavor_name
            )
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin("count", TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin("names", TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter330 in self.names:
                oprot.writeString(
                    iter330.encode("utf-8") if sys.version_info[0] == 2 else iter330
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.start_idx is not None:
            oprot.writeFieldBegin("start_idx", TType.I32, 6)
            oprot.writeI32(self.start_idx)
            oprot.writeFieldEnd()
        if self.batch_idx is not None:
            oprot.writeFieldBegin("batch_idx", TType.I32, 7)
            oprot.writeI32(self.batch_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scale_up_cluster_args)
scale_up_cluster_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "cluster_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "image_name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "flavor_name",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.I32,
        "count",
        None,
        None,
    ),  # 4
    (
        5,
        TType.LIST,
        "names",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 5
    (
        6,
        TType.I32,
        "start_idx",
        None,
        None,
    ),  # 6
    (
        7,
        TType.I32,
        "batch_idx",
        None,
        None,
    ),  # 7
)


class scale_up_cluster_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype332, _vtype333, _size331) = iprot.readMapBegin()
                    for _i335 in range(_size331):
                        _key336 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val337 = []
                        (_etype341, _size338) = iprot.readListBegin()
                        for _i342 in range(_size338):
                            _elem343 = (
                                iprot.readString().decode("utf-8", errors="replace")
                                if sys.version_info[0] == 2
                                else iprot.readString()
                            )
                            _val337.append(_elem343)
                        iprot.readListEnd()
                        self.success[_key336] = _val337
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("scale_up_cluster_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.success))
            for kiter344, viter345 in self.success.items():
                oprot.writeString(
                    kiter344.encode("utf-8") if sys.version_info[0] == 2 else kiter344
                )
                oprot.writeListBegin(TType.STRING, len(viter345))
                for iter346 in viter345:
                    oprot.writeString(
                        iter346.encode("utf-8") if sys.version_info[0] == 2 else iter346
                    )
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(scale_up_cluster_result)
scale_up_cluster_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.LIST, (TType.STRING, "UTF8", False), False),
        None,
    ),  # 0
)


class add_cluster_machine_args(object):
    """
    Attributes:
     - cluster_id
     - cluster_user
     - cluster_group_id
     - image_name
     - flavor_name
     - name
     - key_name
     - batch_idx
     - worker_idx

    """

    thrift_spec = None

    def __init__(
        self,
        cluster_id=None,
        cluster_user=None,
        cluster_group_id=None,
        image_name=None,
        flavor_name=None,
        name=None,
        key_name=None,
        batch_idx=None,
        worker_idx=None,
    ):
        self.cluster_id = cluster_id
        self.cluster_user = cluster_user
        self.cluster_group_id = cluster_group_id
        self.image_name = image_name
        self.flavor_name = flavor_name
        self.name = name
        self.key_name = key_name
        self.batch_idx = batch_idx
        self.worker_idx = worker_idx

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cluster_user = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.cluster_group_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.image_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.flavor_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.key_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.batch_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.worker_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_cluster_machine_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        if self.cluster_user is not None:
            oprot.writeFieldBegin("cluster_user", TType.STRING, 2)
            oprot.writeString(
                self.cluster_user.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_user
            )
            oprot.writeFieldEnd()
        if self.cluster_group_id is not None:
            oprot.writeFieldBegin("cluster_group_id", TType.STRING, 3)
            oprot.writeString(
                self.cluster_group_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_group_id
            )
            oprot.writeFieldEnd()
        if self.image_name is not None:
            oprot.writeFieldBegin("image_name", TType.STRING, 4)
            oprot.writeString(
                self.image_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_name
            )
            oprot.writeFieldEnd()
        if self.flavor_name is not None:
            oprot.writeFieldBegin("flavor_name", TType.STRING, 5)
            oprot.writeString(
                self.flavor_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.flavor_name
            )
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 6)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        if self.key_name is not None:
            oprot.writeFieldBegin("key_name", TType.STRING, 7)
            oprot.writeString(
                self.key_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.key_name
            )
            oprot.writeFieldEnd()
        if self.batch_idx is not None:
            oprot.writeFieldBegin("batch_idx", TType.I32, 8)
            oprot.writeI32(self.batch_idx)
            oprot.writeFieldEnd()
        if self.worker_idx is not None:
            oprot.writeFieldBegin("worker_idx", TType.I32, 9)
            oprot.writeI32(self.worker_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_cluster_machine_args)
add_cluster_machine_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "cluster_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "cluster_user",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "cluster_group_id",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "image_name",
        "UTF8",
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "flavor_name",
        "UTF8",
        None,
    ),  # 5
    (
        6,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 6
    (
        7,
        TType.STRING,
        "key_name",
        "UTF8",
        None,
    ),  # 7
    (
        8,
        TType.I32,
        "batch_idx",
        None,
        None,
    ),  # 8
    (
        9,
        TType.I32,
        "worker_idx",
        None,
        None,
    ),  # 9
)


class add_cluster_machine_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_cluster_machine_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_cluster_machine_result)
add_cluster_machine_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class get_cluster_info_args(object):
    """
    Attributes:
     - cluster_id

    """

    thrift_spec = None

    def __init__(
        self,
        cluster_id=None,
    ):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_info_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_info_args)
get_cluster_info_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "cluster_id",
        "UTF8",
        None,
    ),  # 1
)


class get_cluster_info_result(object):
    """
    Attributes:
     - success
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        c=None,
    ):
        self.success = success
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ClusterInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.c = ClusterNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_info_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_info_result)
get_cluster_info_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [ClusterInfo, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "c",
        [ClusterNotFoundException, None],
        None,
    ),  # 1
)


class get_cluster_status_args(object):
    """
    Attributes:
     - cluster_id

    """

    thrift_spec = None

    def __init__(
        self,
        cluster_id=None,
    ):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_status_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_status_args)
get_cluster_status_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "cluster_id",
        "UTF8",
        None,
    ),  # 1
)


class get_cluster_status_result(object):
    """
    Attributes:
     - success
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        c=None,
    ):
        self.success = success
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype348, _vtype349, _size347) = iprot.readMapBegin()
                    for _i351 in range(_size347):
                        _key352 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val353 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key352] = _val353
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.c = ClusterNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_cluster_status_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter354, viter355 in self.success.items():
                oprot.writeString(
                    kiter354.encode("utf-8") if sys.version_info[0] == 2 else kiter354
                )
                oprot.writeString(
                    viter355.encode("utf-8") if sys.version_info[0] == 2 else viter355
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_cluster_status_result)
get_cluster_status_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "c",
        [ClusterNotFoundException, None],
        None,
    ),  # 1
)


class get_keypair_public_key_by_name_args(object):
    """
    Attributes:
     - key_name

    """

    thrift_spec = None

    def __init__(
        self,
        key_name=None,
    ):
        self.key_name = key_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_keypair_public_key_by_name_args")
        if self.key_name is not None:
            oprot.writeFieldBegin("key_name", TType.STRING, 1)
            oprot.writeString(
                self.key_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.key_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_keypair_public_key_by_name_args)
get_keypair_public_key_by_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "key_name",
        "UTF8",
        None,
    ),  # 1
)


class get_keypair_public_key_by_name_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_keypair_public_key_by_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_keypair_public_key_by_name_result)
get_keypair_public_key_by_name_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
)


class delete_keypair_args(object):
    """
    Attributes:
     - key_name

    """

    thrift_spec = None

    def __init__(
        self,
        key_name=None,
    ):
        self.key_name = key_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_keypair_args")
        if self.key_name is not None:
            oprot.writeFieldBegin("key_name", TType.STRING, 1)
            oprot.writeString(
                self.key_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.key_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_keypair_args)
delete_keypair_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "key_name",
        "UTF8",
        None,
    ),  # 1
)


class delete_keypair_result(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_keypair_result")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_keypair_result)
delete_keypair_result.thrift_spec = ()


class add_default_security_groups_to_server_args(object):
    """
    Attributes:
     - openstack_id

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_default_security_groups_to_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_default_security_groups_to_server_args)
add_default_security_groups_to_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class add_default_security_groups_to_server_result(object):
    """
    Attributes:
     - e

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
    ):
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("add_default_security_groups_to_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(add_default_security_groups_to_server_result)
add_default_security_groups_to_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class get_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_args)
get_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class get_server_result(object):
    """
    Attributes:
     - success
     - e

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_result)
get_server_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [VM, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class get_server_by_unique_name_args(object):
    """
    Attributes:
     - unique_name: Id of the server.

    """

    thrift_spec = None

    def __init__(
        self,
        unique_name=None,
    ):
        self.unique_name = unique_name

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.unique_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_by_unique_name_args")
        if self.unique_name is not None:
            oprot.writeFieldBegin("unique_name", TType.STRING, 1)
            oprot.writeString(
                self.unique_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.unique_name
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_by_unique_name_args)
get_server_by_unique_name_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "unique_name",
        "UTF8",
        None,
    ),  # 1
)


class get_server_by_unique_name_result(object):
    """
    Attributes:
     - success
     - e

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
    ):
        self.success = success
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = VM()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_server_by_unique_name_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_server_by_unique_name_result)
get_server_by_unique_name_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [VM, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
)


class stop_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server.

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("stop_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(stop_server_args)
stop_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class stop_server_result(object):
    """
    Attributes:
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
    ):
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("stop_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(stop_server_result)
stop_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class create_snapshot_args(object):
    """
    Attributes:
     - openstack_id: Id of the server
     - name: Name of new Snapshot
     - username: unique username of the user who requested creation of Snapshot
     - base_tags: Tags with which the servers image is also tagged ( for connection information at the webapp)
     - description: Description of the new snapshot

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
        name=None,
        username=None,
        base_tags=None,
        description=None,
    ):
        self.openstack_id = openstack_id
        self.name = name
        self.username = username
        self.base_tags = base_tags
        self.description = description

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.base_tags = []
                    (_etype359, _size356) = iprot.readListBegin()
                    for _i360 in range(_size356):
                        _elem361 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.base_tags.append(_elem361)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.description = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_snapshot_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 2)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin("username", TType.STRING, 3)
            oprot.writeString(
                self.username.encode("utf-8")
                if sys.version_info[0] == 2
                else self.username
            )
            oprot.writeFieldEnd()
        if self.base_tags is not None:
            oprot.writeFieldBegin("base_tags", TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.base_tags))
            for iter362 in self.base_tags:
                oprot.writeString(
                    iter362.encode("utf-8") if sys.version_info[0] == 2 else iter362
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 5)
            oprot.writeString(
                self.description.encode("utf-8")
                if sys.version_info[0] == 2
                else self.description
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_snapshot_args)
create_snapshot_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "username",
        "UTF8",
        None,
    ),  # 3
    (
        4,
        TType.LIST,
        "base_tags",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 4
    (
        5,
        TType.STRING,
        "description",
        "UTF8",
        None,
    ),  # 5
)


class create_snapshot_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        c=None,
    ):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_snapshot_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_snapshot_result)
create_snapshot_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class get_limits_args(object):
    thrift_spec = None

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_limits_args")
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_limits_args)
get_limits_args.thrift_spec = ()


class get_limits_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype364, _vtype365, _size363) = iprot.readMapBegin()
                    for _i367 in range(_size363):
                        _key368 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val369 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key368] = _val369
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_limits_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter370, viter371 in self.success.items():
                oprot.writeString(
                    kiter370.encode("utf-8") if sys.version_info[0] == 2 else kiter370
                )
                oprot.writeString(
                    viter371.encode("utf-8") if sys.version_info[0] == 2 else viter371
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_limits_result)
get_limits_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class start_cluster_args(object):
    """
    Attributes:
     - public_keys
     - master_instance
     - worker_instances
     - user

    """

    thrift_spec = None

    def __init__(
        self,
        public_keys=None,
        master_instance=None,
        worker_instances=None,
        user=None,
    ):
        self.public_keys = public_keys
        self.master_instance = master_instance
        self.worker_instances = worker_instances
        self.user = user

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.public_keys = []
                    (_etype375, _size372) = iprot.readListBegin()
                    for _i376 in range(_size372):
                        _elem377 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.public_keys.append(_elem377)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.master_instance = ClusterInstance()
                    self.master_instance.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.worker_instances = []
                    (_etype381, _size378) = iprot.readListBegin()
                    for _i382 in range(_size378):
                        _elem383 = ClusterInstance()
                        _elem383.read(iprot)
                        self.worker_instances.append(_elem383)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_cluster_args")
        if self.public_keys is not None:
            oprot.writeFieldBegin("public_keys", TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.public_keys))
            for iter384 in self.public_keys:
                oprot.writeString(
                    iter384.encode("utf-8") if sys.version_info[0] == 2 else iter384
                )
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.master_instance is not None:
            oprot.writeFieldBegin("master_instance", TType.STRUCT, 2)
            self.master_instance.write(oprot)
            oprot.writeFieldEnd()
        if self.worker_instances is not None:
            oprot.writeFieldBegin("worker_instances", TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.worker_instances))
            for iter385 in self.worker_instances:
                iter385.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin("user", TType.STRING, 4)
            oprot.writeString(
                self.user.encode("utf-8") if sys.version_info[0] == 2 else self.user
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_cluster_args)
start_cluster_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.LIST,
        "public_keys",
        (TType.STRING, "UTF8", False),
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "master_instance",
        [ClusterInstance, None],
        None,
    ),  # 2
    (
        3,
        TType.LIST,
        "worker_instances",
        (TType.STRUCT, [ClusterInstance, None], False),
        None,
    ),  # 3
    (
        4,
        TType.STRING,
        "user",
        "UTF8",
        None,
    ),  # 4
)


class start_cluster_result(object):
    """
    Attributes:
     - success

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
    ):
        self.success = success

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype387, _vtype388, _size386) = iprot.readMapBegin()
                    for _i390 in range(_size386):
                        _key391 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val392 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key391] = _val392
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("start_cluster_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter393, viter394 in self.success.items():
                oprot.writeString(
                    kiter393.encode("utf-8") if sys.version_info[0] == 2 else kiter393
                )
                oprot.writeString(
                    viter394.encode("utf-8") if sys.version_info[0] == 2 else viter394
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(start_cluster_result)
start_cluster_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
)


class terminate_cluster_args(object):
    """
    Attributes:
     - cluster_id

    """

    thrift_spec = None

    def __init__(
        self,
        cluster_id=None,
    ):
        self.cluster_id = cluster_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.cluster_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("terminate_cluster_args")
        if self.cluster_id is not None:
            oprot.writeFieldBegin("cluster_id", TType.STRING, 1)
            oprot.writeString(
                self.cluster_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.cluster_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(terminate_cluster_args)
terminate_cluster_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "cluster_id",
        "UTF8",
        None,
    ),  # 1
)


class terminate_cluster_result(object):
    """
    Attributes:
     - success
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        c=None,
    ):
        self.success = success
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype396, _vtype397, _size395) = iprot.readMapBegin()
                    for _i399 in range(_size395):
                        _key400 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val401 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key400] = _val401
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.c = ClusterNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("terminate_cluster_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter402, viter403 in self.success.items():
                oprot.writeString(
                    kiter402.encode("utf-8") if sys.version_info[0] == 2 else kiter402
                )
                oprot.writeString(
                    viter403.encode("utf-8") if sys.version_info[0] == 2 else viter403
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(terminate_cluster_result)
terminate_cluster_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "c",
        [ClusterNotFoundException, None],
        None,
    ),  # 1
)


class delete_image_args(object):
    """
    Attributes:
     - image_id: Id of image

    """

    thrift_spec = None

    def __init__(
        self,
        image_id=None,
    ):
        self.image_id = image_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.image_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_image_args")
        if self.image_id is not None:
            oprot.writeFieldBegin("image_id", TType.STRING, 1)
            oprot.writeString(
                self.image_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.image_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_image_args)
delete_image_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "image_id",
        "UTF8",
        None,
    ),  # 1
)


class delete_image_result(object):
    """
    Attributes:
     - e

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
    ):
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ImageNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_image_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_image_result)
delete_image_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ImageNotFoundException, None],
        None,
    ),  # 1
)


class detach_volume_args(object):
    """
    Attributes:
     - volume_id: Id of the attached volume
     - server_id: Id of the server where the volume is attached

    """

    thrift_spec = None

    def __init__(
        self,
        volume_id=None,
        server_id=None,
    ):
        self.volume_id = volume_id
        self.server_id = server_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.server_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("detach_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        if self.server_id is not None:
            oprot.writeFieldBegin("server_id", TType.STRING, 2)
            oprot.writeString(
                self.server_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.server_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(detach_volume_args)
detach_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "server_id",
        "UTF8",
        None,
    ),  # 2
)


class detach_volume_result(object):
    """
    Attributes:
     - e
     - c
     - v

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
        v=None,
    ):
        self.e = e
        self.c = c
        self.v = v

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.v = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("detach_volume_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin("v", TType.STRUCT, 3)
            self.v.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(detach_volume_result)
detach_volume_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
    (
        3,
        TType.STRUCT,
        "v",
        [VolumeNotFoundException, None],
        None,
    ),  # 3
)


class delete_volume_args(object):
    """
    Attributes:
     - volume_id

    """

    thrift_spec = None

    def __init__(
        self,
        volume_id=None,
    ):
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_args)
delete_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 1
)


class delete_volume_result(object):
    """
    Attributes:
     - c
     - v

    """

    thrift_spec = None

    def __init__(
        self,
        c=None,
        v=None,
    ):
        self.c = c
        self.v = v

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.v = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_result")
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin("v", TType.STRUCT, 2)
            self.v.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_result)
delete_volume_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "v",
        [VolumeNotFoundException, None],
        None,
    ),  # 2
)


class attach_volume_to_server_args(object):
    """
    Attributes:
     - openstack_id: Id of server
     - volume_id: Id of volume

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
        volume_id=None,
    ):
        self.openstack_id = openstack_id
        self.volume_id = volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("attach_volume_to_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 2)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(attach_volume_to_server_args)
attach_volume_to_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 2
)


class attach_volume_to_server_result(object):
    """
    Attributes:
     - success
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        c=None,
    ):
        self.success = success
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype405, _vtype406, _size404) = iprot.readMapBegin()
                    for _i408 in range(_size404):
                        _key409 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val410 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.success[_key409] = _val410
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("attach_volume_to_server_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter411, viter412 in self.success.items():
                oprot.writeString(
                    kiter411.encode("utf-8") if sys.version_info[0] == 2 else kiter411
                )
                oprot.writeString(
                    viter412.encode("utf-8") if sys.version_info[0] == 2 else viter412
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(attach_volume_to_server_result)
attach_volume_to_server_result.thrift_spec = (
    (
        0,
        TType.MAP,
        "success",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [VolumeNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class resume_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resume_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resume_server_args)
resume_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class resume_server_result(object):
    """
    Attributes:
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
    ):
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("resume_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(resume_server_result)
resume_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class create_volume_args(object):
    """
    Attributes:
     - volume_name: Name of volume
     - volume_storage: Diskspace in GB for new volume
     - metadata: Metadata for the new volume

    """

    thrift_spec = None

    def __init__(
        self,
        volume_name=None,
        volume_storage=None,
        metadata=None,
    ):
        self.volume_name = volume_name
        self.volume_storage = volume_storage
        self.metadata = metadata

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.volume_storage = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype414, _vtype415, _size413) = iprot.readMapBegin()
                    for _i417 in range(_size413):
                        _key418 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val419 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key418] = _val419
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_args")
        if self.volume_name is not None:
            oprot.writeFieldBegin("volume_name", TType.STRING, 1)
            oprot.writeString(
                self.volume_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_name
            )
            oprot.writeFieldEnd()
        if self.volume_storage is not None:
            oprot.writeFieldBegin("volume_storage", TType.I32, 2)
            oprot.writeI32(self.volume_storage)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter420, viter421 in self.metadata.items():
                oprot.writeString(
                    kiter420.encode("utf-8") if sys.version_info[0] == 2 else kiter420
                )
                oprot.writeString(
                    viter421.encode("utf-8") if sys.version_info[0] == 2 else viter421
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_args)
create_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.I32,
        "volume_storage",
        None,
        None,
    ),  # 2
    (
        3,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 3
)


class create_volume_result(object):
    """
    Attributes:
     - success
     - r
     - n

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        r=None,
        n=None,
    ):
        self.success = success
        self.r = r
        self.n = n

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.n = ResourceNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin("n", TType.STRUCT, 2)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_result)
create_volume_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Volume, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "n",
        [ResourceNotAvailableException, None],
        None,
    ),  # 2
)


class create_volume_by_source_volume_args(object):
    """
    Attributes:
     - volume_name: Name of volume
     - metadata: Metadata for the new volume
     - source_volume_id: ID of source volume

    """

    thrift_spec = None

    def __init__(
        self,
        volume_name=None,
        metadata=None,
        source_volume_id=None,
    ):
        self.volume_name = volume_name
        self.metadata = metadata
        self.source_volume_id = source_volume_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype423, _vtype424, _size422) = iprot.readMapBegin()
                    for _i426 in range(_size422):
                        _key427 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val428 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key427] = _val428
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_by_source_volume_args")
        if self.volume_name is not None:
            oprot.writeFieldBegin("volume_name", TType.STRING, 1)
            oprot.writeString(
                self.volume_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_name
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter429, viter430 in self.metadata.items():
                oprot.writeString(
                    kiter429.encode("utf-8") if sys.version_info[0] == 2 else kiter429
                )
                oprot.writeString(
                    viter430.encode("utf-8") if sys.version_info[0] == 2 else viter430
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_volume_id is not None:
            oprot.writeFieldBegin("source_volume_id", TType.STRING, 3)
            oprot.writeString(
                self.source_volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.source_volume_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_by_source_volume_args)
create_volume_by_source_volume_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "source_volume_id",
        "UTF8",
        None,
    ),  # 3
)


class create_volume_by_source_volume_result(object):
    """
    Attributes:
     - success
     - r
     - n

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        r=None,
        n=None,
    ):
        self.success = success
        self.r = r
        self.n = n

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.n = ResourceNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_by_source_volume_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin("n", TType.STRUCT, 2)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_by_source_volume_result)
create_volume_by_source_volume_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Volume, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "n",
        [ResourceNotAvailableException, None],
        None,
    ),  # 2
)


class create_volume_by_volume_snap_args(object):
    """
    Attributes:
     - volume_name: Name of volume
     - metadata: Metadata for the new volume
     - volume_snap_id: ID of volume snapshot

    """

    thrift_spec = None

    def __init__(
        self,
        volume_name=None,
        metadata=None,
        volume_snap_id=None,
    ):
        self.volume_name = volume_name
        self.metadata = metadata
        self.volume_snap_id = volume_snap_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.metadata = {}
                    (_ktype432, _vtype433, _size431) = iprot.readMapBegin()
                    for _i435 in range(_size431):
                        _key436 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        _val437 = (
                            iprot.readString().decode("utf-8", errors="replace")
                            if sys.version_info[0] == 2
                            else iprot.readString()
                        )
                        self.metadata[_key436] = _val437
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.volume_snap_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_by_volume_snap_args")
        if self.volume_name is not None:
            oprot.writeFieldBegin("volume_name", TType.STRING, 1)
            oprot.writeString(
                self.volume_name.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_name
            )
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin("metadata", TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metadata))
            for kiter438, viter439 in self.metadata.items():
                oprot.writeString(
                    kiter438.encode("utf-8") if sys.version_info[0] == 2 else kiter438
                )
                oprot.writeString(
                    viter439.encode("utf-8") if sys.version_info[0] == 2 else viter439
                )
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.volume_snap_id is not None:
            oprot.writeFieldBegin("volume_snap_id", TType.STRING, 3)
            oprot.writeString(
                self.volume_snap_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_snap_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_by_volume_snap_args)
create_volume_by_volume_snap_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_name",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.MAP,
        "metadata",
        (TType.STRING, "UTF8", TType.STRING, "UTF8", False),
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "volume_snap_id",
        "UTF8",
        None,
    ),  # 3
)


class create_volume_by_volume_snap_result(object):
    """
    Attributes:
     - success
     - r
     - n

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        r=None,
        n=None,
    ):
        self.success = success
        self.r = r
        self.n = n

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Volume()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.n = ResourceNotAvailableException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_by_volume_snap_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        if self.n is not None:
            oprot.writeFieldBegin("n", TType.STRUCT, 2)
            self.n.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_by_volume_snap_result)
create_volume_by_volume_snap_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Volume, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "n",
        [ResourceNotAvailableException, None],
        None,
    ),  # 2
)


class create_volume_snapshot_args(object):
    """
    Attributes:
     - volume_id: ID of source volume
     - name: Name for the volume snapshot
     - description: Description for the volume snapshot

    """

    thrift_spec = None

    def __init__(
        self,
        volume_id=None,
        name=None,
        description=None,
    ):
        self.volume_id = volume_id
        self.name = name
        self.description = description

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.volume_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_snapshot_args")
        if self.volume_id is not None:
            oprot.writeFieldBegin("volume_id", TType.STRING, 1)
            oprot.writeString(
                self.volume_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.volume_id
            )
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin("name", TType.STRING, 2)
            oprot.writeString(
                self.name.encode("utf-8") if sys.version_info[0] == 2 else self.name
            )
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin("description", TType.STRING, 3)
            oprot.writeString(
                self.description.encode("utf-8")
                if sys.version_info[0] == 2
                else self.description
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_snapshot_args)
create_volume_snapshot_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "volume_id",
        "UTF8",
        None,
    ),  # 1
    (
        2,
        TType.STRING,
        "name",
        "UTF8",
        None,
    ),  # 2
    (
        3,
        TType.STRING,
        "description",
        "UTF8",
        None,
    ),  # 3
)


class create_volume_snapshot_result(object):
    """
    Attributes:
     - success
     - e
     - r

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        e=None,
        r=None,
    ):
        self.success = success
        self.e = e
        self.r = r

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.e = VolumeNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.r = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("create_volume_snapshot_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRING, 0)
            oprot.writeString(
                self.success.encode("utf-8")
                if sys.version_info[0] == 2
                else self.success
            )
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 2)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(create_volume_snapshot_result)
create_volume_snapshot_result.thrift_spec = (
    (
        0,
        TType.STRING,
        "success",
        "UTF8",
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [VolumeNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "r",
        [DefaultException, None],
        None,
    ),  # 2
)


class get_volume_snapshot_args(object):
    """
    Attributes:
     - name_or_id: Name or ID of volume snapshot

    """

    thrift_spec = None

    def __init__(
        self,
        name_or_id=None,
    ):
        self.name_or_id = name_or_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name_or_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_snapshot_args")
        if self.name_or_id is not None:
            oprot.writeFieldBegin("name_or_id", TType.STRING, 1)
            oprot.writeString(
                self.name_or_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.name_or_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_snapshot_args)
get_volume_snapshot_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "name_or_id",
        "UTF8",
        None,
    ),  # 1
)


class get_volume_snapshot_result(object):
    """
    Attributes:
     - success
     - r

    """

    thrift_spec = None

    def __init__(
        self,
        success=None,
        r=None,
    ):
        self.success = success
        self.r = r

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Snapshot()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.r = ResourceNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("get_volume_snapshot_result")
        if self.success is not None:
            oprot.writeFieldBegin("success", TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.r is not None:
            oprot.writeFieldBegin("r", TType.STRUCT, 1)
            self.r.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(get_volume_snapshot_result)
get_volume_snapshot_result.thrift_spec = (
    (
        0,
        TType.STRUCT,
        "success",
        [Snapshot, None],
        None,
    ),  # 0
    (
        1,
        TType.STRUCT,
        "r",
        [ResourceNotFoundException, None],
        None,
    ),  # 1
)


class delete_volume_snapshot_args(object):
    """
    Attributes:
     - snapshot_id

    """

    thrift_spec = None

    def __init__(
        self,
        snapshot_id=None,
    ):
        self.snapshot_id = snapshot_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.snapshot_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_snapshot_args")
        if self.snapshot_id is not None:
            oprot.writeFieldBegin("snapshot_id", TType.STRING, 1)
            oprot.writeString(
                self.snapshot_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.snapshot_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_snapshot_args)
delete_volume_snapshot_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "snapshot_id",
        "UTF8",
        None,
    ),  # 1
)


class delete_volume_snapshot_result(object):
    """
    Attributes:
     - c
     - e

    """

    thrift_spec = None

    def __init__(
        self,
        c=None,
        e=None,
    ):
        self.c = c
        self.e = e

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.e = DefaultException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("delete_volume_snapshot_result")
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 1)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 2)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(delete_volume_snapshot_result)
delete_volume_snapshot_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "e",
        [DefaultException, None],
        None,
    ),  # 2
)


class reboot_hard_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_hard_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_hard_server_args)
reboot_hard_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class reboot_hard_server_result(object):
    """
    Attributes:
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
    ):
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_hard_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_hard_server_result)
reboot_hard_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)


class reboot_soft_server_args(object):
    """
    Attributes:
     - openstack_id: Id of the server

    """

    thrift_spec = None

    def __init__(
        self,
        openstack_id=None,
    ):
        self.openstack_id = openstack_id

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.openstack_id = (
                        iprot.readString().decode("utf-8", errors="replace")
                        if sys.version_info[0] == 2
                        else iprot.readString()
                    )
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_soft_server_args")
        if self.openstack_id is not None:
            oprot.writeFieldBegin("openstack_id", TType.STRING, 1)
            oprot.writeString(
                self.openstack_id.encode("utf-8")
                if sys.version_info[0] == 2
                else self.openstack_id
            )
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_soft_server_args)
reboot_soft_server_args.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRING,
        "openstack_id",
        "UTF8",
        None,
    ),  # 1
)


class reboot_soft_server_result(object):
    """
    Attributes:
     - e
     - c

    """

    thrift_spec = None

    def __init__(
        self,
        e=None,
        c=None,
    ):
        self.e = e
        self.c = c

    def read(self, iprot):
        if (
            iprot._fast_decode is not None
            and isinstance(iprot.trans, TTransport.CReadableTransport)
            and self.thrift_spec is not None
        ):
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.e = ServerNotFoundException.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.c = OpenStackConflictException.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        self.validate()
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(
                oprot._fast_encode(self, [self.__class__, self.thrift_spec])
            )
            return
        oprot.writeStructBegin("reboot_soft_server_result")
        if self.e is not None:
            oprot.writeFieldBegin("e", TType.STRUCT, 1)
            self.e.write(oprot)
            oprot.writeFieldEnd()
        if self.c is not None:
            oprot.writeFieldBegin("c", TType.STRUCT, 2)
            self.c.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ["%s=%r" % (key, value) for key, value in self.__dict__.items()]
        return "%s(%s)" % (self.__class__.__name__, ", ".join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


all_structs.append(reboot_soft_server_result)
reboot_soft_server_result.thrift_spec = (
    None,  # 0
    (
        1,
        TType.STRUCT,
        "e",
        [ServerNotFoundException, None],
        None,
    ),  # 1
    (
        2,
        TType.STRUCT,
        "c",
        [OpenStackConflictException, None],
        None,
    ),  # 2
)
fix_spec(all_structs)
del all_structs
